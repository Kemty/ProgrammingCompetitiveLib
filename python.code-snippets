{
	// Place your Python38 ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	"timer": {
		"prefix": "timer",
		"body": [
			"from time import perf_counter",
			"",
			"def timer(func):",
			"    def wrapper(arg):",
			"        begin = perf_counter()",
			"        func(arg)",
			"        end = perf_counter()",
			"        print(f'{func.__name__}: {(end-begin)*1000}ms')",
			"    return wrapper",
			"",
		],
		"description": "関数の実行時間を計測するwrapper"
	},
	
	"template": {
		"prefix": "omajinai",
		"body": [
		  "from collections import defaultdict, deque, Counter",
		  "import copy",
		  "from itertools import combinations, permutations, product, accumulate, groupby",
		  "from heapq import heapify, heappop, heappush",
		  "import math",
		  "import bisect",
		  "from pprint import pprint",
		  "from random import randint",
		  "import sys",
		  "# sys.setrecursionlimit(700000)",
		  "input = lambda: sys.stdin.readline().rstrip('\\n')",
		  "inf = float('inf')",
		  "mod1 = 10**9+7",
		  "mod2 = 998244353",
		  "def ceil_div(x, y): return -(-x//y)",
		  "",
		  "#################################################",
		  ""
		],
		"description": "template"
	  },

	"list(map(int, input().split()))": {
		"prefix": "lmi",
		"body": [
			"${1:hoge} = list(map(int, input().split()))",
		],
		"description": "list(map(int, input().split()))"
	},

	"map(int, input().split())": {
		"prefix": "mi",
		"body": [
			"${1:hogehoge} = map(int, input().split())",
		],
		"description": "map(int, input().split())"
	},

	"tuple(map(int, input().split()))": {
		"prefix": "tmi",
		"body": [
			"${1:hoge} = tuple(map(int, input().split()))",
		],
		"description": "tuple(map(int,input().split()))"
	},

	"int(input())": {
		"prefix": "ii",
		"body": [
			"${1:hoge} = int(input())",
		],
		"description": "int(input())"
	},

	"compression": {
		"prefix": "comp",
		"body": [
			"${1:array}_decomp = sorted(set(${1:array}))",
			"${1:array}_comp = {a: i for i, a in enumerate(${1:array}_decomp)}",
		],
		"description": "座標圧縮",
	},

	"binary_search": {
		"prefix": "nibutan",
		"body": [
			"ok, ng = ",
			"while(abs(ok-ng)>1):",
			"    mid = (ok+ng)//2",
			"    if judge(mid):",
			"        ok = mid",
			"    else:",
			"        ng = mid"
		],
		"description": "binary_search"
	},

	"setlimit": {
		"prefix": "setlimit",
		"body": [
			"import sys",
			"sys.setrecursionlimit(10**9)"
		],
		"description": "import sys"
	},

	"base_int": {
		"prefix": "base_int",
		"body": [
			"def base_int(value, base):",
			"    if value//base:",
			"        return base_int(value//base, base)+[value%base]",
			"    return [value%base]"
		],
		"description": "base_int"
	},

	"Binary_Indexed_Tree": {
		"prefix": "BIT",
		"body": [
			"class BIT:",
			"    n = None",
			"    tree = None",
			"    def __init__(self, array, mod=mod1):",
			"        self.n = len(array)+1",
			"        self.mod = mod",
			"        self.tree = [0]*self.n",
			"        for i in range(len(array)):",
			"            self.add(i, array[i])",
			"",
			"    # array[i] += x",
			"    def add(self, i, x):",
			"        i += 1",
			"        while i < self.n:",
			"            self.tree[i] += x",
			"            # self.tree[i] %= self.mod",
			"            i += i&-i",
			"",
			"    # sum(array[:i])",
			"    def sum(self, i):",
			"        ret = 0",
			"        while i > 0:",
			"            ret += self.tree[i]",
			"            # ret %= self.mod",
			"            i -= i&-i",
			"        return ret",
			"",
			"    # sum(array[l:r])",
			"    def sum_range(self, l, r):",
			"        if l >= r: return 0",
			"        return (self.sum(r)-self.sum(l))",
			"        # return (self.sum(r)-self.sum(l))%self.mod",
			"",
			"    # array[i]",
			"    def get(self, i):",
			"        return self.sum_range(i, i+1)",
			"",
			"    # sum(array[:i]) >= x を満たす最小のi (array: 非負整数列)",
			"    def lower_bound(self, x):",
			"        i, r = 0, 1",
			"        r <<= self.n.bit_length()",
			"        while r > 0:",
			"            if i+r < self.n and self.tree[i+r] < x:",
			"                x -= self.tree[i+r]",
			"                i += r",
			"            r >>= 1",
			"        return i+1 if i < self.n-1 else None",
			"",
			"    # sum(array[:i]) > x を満たす最小のi (array: 非負整数列)",
			"    def upper_bound(self, x):",
			"        i, length = 0, 1",
			"        length <<= self.n.bit_length()",
			"        while length > 0:",
			"            if i+length < self.n and self.tree[i+length] <= x:",
			"                x -= self.tree[i+length]",
			"                i += length",
			"            length >>= 1",
			"        return i+1 if i < self.n-1 else None",
			"",
		],
		"description": "Binary_indexed_Tree"
	},

	"BIT2D": {
		"prefix": "BIT2D",
		"body": [
			"class BIT2D:",
			"    h, w = 0, 0",
			"    trees = None",
			"    def __init__(self, points):",
			"        for i, j, x in points:",
			"            self.h, self.w = max(self.h, i+1), max(self.w, j+1)",
			"        trees = [[0]*self.w for _ in range(self.h)]",
			"        for i, j, value in points:",
			"            self.add(i, j, x)",
			"",
			"    # matrix[i][j] += x",
			"    def add(self, i, j, x):",
			"        idx = i+1",
			"        while idx > 0:",
			"            jdx = j+1",
			"            while jdx > 0:",
			"                self.trees[i][j] += x",
			"                jdx += jdx&-jdx",
			"            idx += idx&-idx",
			"",
			"    # sum(matrix[:i][:j])",
			"    def sum(self, i, j):",
			"        ret = 0",
			"        idx = i",
			"        while idx > 0:",
			"            jdx = j",
			"            while jdx > 0:",
			"                ret += self.trees[idx][jdx]",
			"                jdx -= jdx&-jdx",
			"            idx -= idx&-idx",
			"        return ret",
			"",
			"    # sum(matrix[i1:i2][j1:j2])",
			"    def sum_range(self, i1, j1, i2, j2):",
			"        return self.trees[i2][j2]-self.trees[i1][j2]-self.trees[i2][j1]+self.trees[i1][j1]"
		],
		"description": "BIT2D"
	},

	"Union-Find": {
		"prefix": "unionfind",
		"body": [
			"class UnionFind:",
			"    #コンストラクタ",
			"    def __init__(self, n):",
			"        self.n = n",
			"        self.parents = [-1]*n",
			"",
			"    #点xの根を調べる+親が根になるよう移動",
			"    def find(self, x):",
			"        if self.parents[x] < 0:",
			"            return x",
			"        else:",
			"            self.parents[x] = self.find(self.parents[x])",
			"            return self.parents[x]",
			"",
			"    #点x,yの属する集合同士を連結(要素数が少ない方を多い方に連結)",
			"    #辺を追加したらTrue, しなければFalseを返す",
			"    def union(self, x, y):",
			"        x = self.find(x)",
			"        y = self.find(y)",
			"        if x == y:",
			"            return False",
			"        if self.parents[x] > self.parents[y]:",
			"            x, y = y, x",
			"        self.parents[x] += self.parents[y]",
			"        self.parents[y] = x",
			"        return True",
			"",
			"    #点xが属する集合の要素数を取得",
			"    def size(self, x):",
			"        return -self.parents[self.find(x)]",
			"",
			"    #点x,yが同じ集合に属しているか判定",
			"    def same(self, x, y):",
			"        return self.find(x) == self.find(y)",
			"",
			"    #点xの属する集合の全要素を取得",
			"    def members(self, x):",
			"        root = self.find(x)",
			"        return [i for i in range(self.n) if self.find(i) == root]",
			"",
			"    #根になっている全要素を取得",
			"    def roots(self):",
			"        return [i for i, x in enumerate(self.parents) if x < 0]",
			"",
			"    #集合の数を取得",
			"    def group_count(self):",
			"        return len(self.roots())",
			"",
			"    #全集合の「根と全要素」を取得",
			"    def get_groups(self):",
			"        groups = defaultdict(list)",
			"        for x in range(self.n):",
			"            groups[self.find(x)].append(x)",
			"        return groups",
			"",
			"    #print(インスタンス)で、全集合の「根と全要素」を出力",
			"    def __str__(self):",
			"        return '\\n'.join('{}:{}'.format(r, self.menbers(r)) for r in self.roots())"
		],
		"description": "unionfind"
	},

"重み付き Union-Find": {
  "prefix": "wuf",
  "body": [
    "class WeightedUnionFind:",
    "    #コンストラクタ",
    "    def __init__(self, n, op=lambda x,y: x+y, e=0, inv=lambda x: -x):",
    "        self.n = n",
    "        self.op = op",
    "        self.e = e",
    "        self.inv = inv",
    "        self.parents = [-1]*n",
    "        self.weight = [e]*n",
    "",
    "    #点xの根と根までの距離を調べる+親が根になるよう移動し辺の重みを更新",
    "    def find(self, x):",
    "        if self.parents[x] < 0:",
    "            return x, self.e",
    "        else:",
    "            r, w = self.find(self.parents[x])",
    "            self.parents[x] = r",
    "            self.weight[x] = self.op(self.weight[x], w)",
    "            return self.parents[x], self.weight[x]",
    "",
    "    #点x,yの属する集合同士を連結(要素数が少ない方を多い方に連結)",
    "    #x->yの距離がwとなるように辺を張る",
    "    #既に連結済みである場合、x->yの距離がwでなければ何もせずにFalseをreturn",
    "    #それ以外の場合はTrueをreturn",
    "    def union(self, x, y, w):",
    "        rx, wx = self.find(x)",
    "        ry, wy = self.find(y)",
    "        if rx == ry:",
    "            return self.op(wx, self.inv(wy)) == w",
    "        if self.parents[rx] < self.parents[ry]:",
    "            self.weight[ry] = self.op(self.op(self.inv(w), wx), self.inv(wy))",
    "            self.parents[rx] += self.parents[ry]",
    "            self.parents[ry] = rx",
    "        else:",
    "            self.weight[rx] = self.op(self.op(w, self.inv(wx)), wy)",
    "            self.parents[ry] += self.parents[rx]",
    "            self.parents[rx] = ry",
    "        return True",
    "",
    "    #点xが属する集合の要素数を取得",
    "    def size(self, x):",
    "        return -self.parents[self.find(x)[0]]",
    "",
    "    #点x,yが同じ集合に属しているか判定",
    "    def same(self, x, y):",
    "        return self.find(x)[0] == self.find(y)[0]",
    "",
    "    #点xの属する集合の全要素を取得",
    "    def members(self, x):",
    "        root = self.find(x)",
    "        return [i for i in range(self.n) if self.find(i)[0] == root]",
    "",
    "    #根になっている全要素を取得",
    "    def roots(self):",
    "        return [i for i, x in enumerate(self.parents) if x < 0]",
    "",
    "    #集合の数を取得",
    "    def group_count(self):",
    "        return len(self.roots())",
    "",
    "    #全集合の「根と全要素」を取得",
    "    def get_groups(self):",
    "        groups = defaultdict(list)",
    "        for x in range(self.n):",
    "            groups[self.find(x)[0]].append(x)",
    "        return groups",
    "",
    "    # x->yの距離を取得",
    "    # 非連結の場合Noneをreturn",
    "    def dist(self, x, y):",
    "        rx, wx = self.find(x)",
    "        ry, wy = self.find(y)",
    "        if rx != ry:",
    "            return None",
    "        else:",
    "            return self.op(wx, self.inv(wy))",
    "",
    "    #print(インスタンス)で、全集合の「根と全要素」を出力",
    "    def __str__(self):",
    "        return '\\n'.join('{}:{}'.format(r, self.members(r)) for r in self.roots())",
    "",
    "# 2部グラフ用",
    "class BipartiteGraph_UF(WeightedUnionFind):",
    "    def __init__(self, n):",
    "        super().__init__(n, op=lambda x, y: x^y, e=0, inv=lambda x: x)",
    "    def union(self, x, y):",
    "        return super().union(x, y, 1)",
    ""
  ],
  "description": "重み付き Union-Find"
},

	"dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"def dijkstra(s):",
			"    dist = [inf]*N",
			"    dist[s] = 0",
			"    hq = [(0, s)]",
			"    while hq:",
			"        d, now = heappop(hq)",
			"        if d > dist[now]: continue",
			"        for next, cost in adj[now]:",
			"            nd = d+cost",
			"            if dist[next] <= nd: continue",
			"            dist[next] = nd",
			"            heappush(hq, (nd, next)) ",
			"    return dist"
		],
		"description": "dijkstra"
	},

	"cmbination": {
		"prefix": "cmb",
		"body": [
			"def cmb(n, r):",
			"    if r < 0 or r > n:",
			"        return 0",
			"    r = min(r, n-r)",
			"    return fact[n]*factinv[r]%p*factinv[n-r]%p",
			"",
			"def pmt(n, r):",
			"    if r < 0 or r > n:",
			"        return 0",
			"    return fact[n]*factinv[n-r]%p",
			"",
			"p = 10**9+7",
			"N = 10**6 #Nは必要分だけ用意する",
			"fact = [1, 1] #fact[n]: n! mod p",
			"factinv = [1, 1] #factinv[n]: n!^(-1) mod p",
			"inv = [0, 1] #inv[n]: n^(-1) mod p",
			"",
			"for i in range(2, N+1):",
			"    fact.append((fact[-1]*i)%p)",
			"    inv.append((-inv[p%i]*(p//i))%p)",
			"    factinv.append((factinv[-1]*inv[-1])%p)",
		],
		"description": "combination"
	},

	"prime_factorize": {
		"prefix": "primefact",
		"body": [
			"def prime_factorize(n):",
			"    ret = defaultdict(int)",
			"    i = 2",
			"    while i*i <= n:",
			"        if n%i == 0:",
			"            ret[i] += 1",
			"            n //= i",
			"        else:",
			"            i += 1",
			"    if n != 1:",
			"        ret[n] += 1",
			"    return ret",
			""
		],
		"description": "prime_factorize"
	},

	"eratosthenes": {
		"prefix": "eratos",
		"body": [
			"class Eratos:",
			"    def __init__(self, n) -> None:",
			"        self.n = n",
			"        self.primes = []",
			"        self.lpf = [None]*(n+1)",
			"        for d in range(2, n+1):",
			"            if self.lpf[d] is None:",
			"                self.primes.append(d)",
			"                self.lpf[d] = d",
			"                for p in range(d+d, n+1, d):",
			"                    if self.lpf[p] is None:",
			"                        self.lpf[p] = d",
			"    def factorize(self, n):",
			"        ret = defaultdict(int)",
			"        while n > 1:",
			"            ret[self.lpf[n]] += 1",
			"            n //= self.lpf[n]",
			"        return ret"
		],
		"description": "make_prime_table"
	},

	"factor": {
		"prefix": "factor",
		"body": [
			"def factor(x):",
			"    retm, retM = [], []",
			"    i = 1",
			"    while i*i <= x:",
			"        if x%i == 0:",
			"            retm.append(i)",
			"            if x//i != i:",
			"                retM.append(x//i)",
			"        i += 1",
			"    return retm+retM[::-1]",
			""
		],
		"description": "enumerate divisors"
	},

	"LCA": {
		"prefix": "LCA",
		"body": [
			"logn = N.bit_length()",
			"doubling = [[None]*N for _ in range(logn)]",
			"depth = [inf]*N",
			"depth[0] = 0",
			"stack = [0]",
			"while stack:",
			"    now = stack.pop()",
			"    for next in adj[now]:",
			"        if depth[next] == inf:",
			"            depth[next] = depth[now]+1",
			"            doubling[0][next] = now",
			"            stack.append(next)",
			"",
			"base = 2",
			"for i in range(1, logn):",
			"    for j in range(N):",
			"        if depth[j] >= base:",
			"            doubling[i][j] = doubling[i-1][doubling[i-1][j]]",
			"    base <<= 1",
			"",
			"def lca(a, b):",
			"    if depth[b] < depth[a]: a, b = b, a",
			"    d = depth[b]-depth[a]",
			"    i = 0",
			"    while d:",
			"        if d&1: b = doubling[i][b]",
			"        d >>= 1",
			"        i += 1",
			"    while a != b:",
			"        ok, ng = 0, logn",
			"        while(abs(ok-ng)>1):",
			"            mid = (ok+ng)//2",
			"            if doubling[mid][a] is not None and doubling[mid][a] != doubling[mid][b]:",
			"                ok = mid",
			"            else:",
			"                ng = mid",
			"        a, b = doubling[ok][a], doubling[ok][b]",
			"    return a",
			""
		],
		"description": "Lowest Common Ancestor"
	},

	"SCC": {
		"prefix": "SCC",
		"body": [
			"def sccd(adj):",
			"    n = len(adj)",
			"    been = [False]*n",
			"    P = []",
			"    for s in range(n):",
			"        if been[s]: continue",
			"        stack = [s]",
			"        while stack:",
			"            now = stack.pop()",
			"            if now >= 0:",
			"                if been[now]: continue",
			"                been[now] = True",
			"                stack.append(~now)",
			"                for nxt in adj[now]:",
			"                    if been[nxt]: continue",
			"                    stack.append(nxt)",
			"            else:",
			"                P.append(~now)",
			"    radj = [[] for _ in range(n)]",
			"    for i, neighbor in enumerate(adj):",
			"        for j in neighbor:",
			"            radj[j].append(i)",
			"    scc_prev = []",
			"    scc_idx = [None]*n",
			"    for s in reversed(P):",
			"        if not been[s]: continue",
			"        been[s] = False",
			"        stack = [s]",
			"        scc = []",
			"        while stack:",
			"            now = stack.pop()",
			"            scc_idx[now] = (len(scc_prev), len(scc))",
			"            scc.append(now)",
			"            for nxt in radj[now]:",
			"                if not been[nxt]: continue",
			"                been[nxt] = False",
			"                stack.append(nxt)",
			"        scc_prev.append(scc)",
			"    scc_adj = [None]*len(scc_prev)",
			"    for i, scc in enumerate(scc_prev):",
			"        neighbor = set()",
			"        for now in scc:",
			"            for nxt in adj[now]:",
			"                j = scc_idx[nxt][0]",
			"                if j != i: neighbor.add(j)",
			"        scc_adj[i] = list(neighbor)",
			"    return scc_adj, scc_idx, scc_prev",
			"",
		],
		"description": "Strongly Connencted Component"
	},

	"Doubling": {
		"prefix": "Doubling",
		"body": [
			"class FG_doubling:",
			"    def __init__(self, next, weight, op, e, K=60) -> None:",
			"        self.N = len(next)",
			"        self.K = K",
			"        self.next = next",
			"        self.weight = weight",
			"        self.op = op",
			"        self.e = e",
			"        self.doubling_next = [self.next]+[[None]*self.N for _ in range(self.K)]",
			"        self.doubling_weight = [self.weight]+[[None]*self.N for _ in range(self.K)]",
			"        for k in range(self.K):",
			"            for i in range(self.N):",
			"                self.doubling_next[k+1][i] = self.doubling_next[k][self.doubling_next[k][i]]",
			"                self.doubling_weight[k+1][i] = self.op(self.doubling_weight[k][self.doubling_next[k][i]], self.doubling_weight[k][i])",
			"    def move(self, fr, k):",
			"        i = 0",
			"        while k:",
			"            if k&1:",
			"                fr = self.doubling_next[i][fr]",
			"            i += 1",
			"            k >>= 1",
			"        return fr",
			"    def prod(self, fr, k):",
			"        i = 0",
			"        w = self.e",
			"        while k:",
			"            if k&1:",
			"                w = self.op(w, self.doubling_weight[i][fr])",
			"                fr = self.doubling_next[i][fr]",
			"            i += 1",
			"            k >>= 1",
			"        return w",
			"    def move_prod(self, fr, k):",
			"        i = 0",
			"        w = self.e",
			"        while k:",
			"            if k&1:",
			"                w = self.op(w, self.doubling_weight[i][fr])",
			"                fr = self.doubling_next[i][fr]",
			"            i += 1",
			"            k >>= 1",
			"        return fr, w",
			"    def move_S(self, S, k):",
			"        i = 0",
			"        T = S[:]",
			"        while k:",
			"            if k&1:",
			"                for j in range(len(S)):",
			"                    T[j] = self.doubling_next[i][T[j]]",
			"            i += 1",
			"            k >>= 1",
			"        return T",
			"    def lower_bound(self, fr, x):",
			"        if x <= self.e: return self.e",
			"        w = self.e",
			"        k = 0",
			"        i = self.K",
			"        while True:",
			"            while i >= 0 and x <= self.op(w, self.doubling_weight[i][fr]):",
			"                i -= 1",
			"            if i == -1: break",
			"            w = self.op(w, self.doubling_weight[i][fr])",
			"            fr = self.doubling_next[i][fr]",
			"            k += 1<<i",
			"            i -= 1",
			"        if x <= self.op(w, self.weight[fr]): return self.next[fr], k+1 ",
			"        return None, None",
			"    def upper_bound(self, fr, x):",
			"        w = self.e",
			"        k = 0",
			"        i = self.K",
			"        while True:",
			"            while i >= 0 and x < self.op(w, self.doubling_weight[i][fr]):",
			"                i -= 1",
			"            if i == -1: break",
			"            w = self.op(w, self.doubling_weight[i][fr])",
			"            fr = self.doubling_next[i][fr]",
			"            k += 1<<i",
			"            i -= 1",
			"        if x < self.op(w, self.weight[fr]): return self.next[fr], k+1",
			"        return None, None",
			"",
			"class Tree_doubling(FG_doubling):",
			"    def __init__(self, adj, root, op, e):",
			"        n = len(adj)",
			"        self.root = root",
			"        self.depth = [None]*(n+1)",
			"        self.depth[n] = -1",
			"        self.depth[root] = 0",
			"        self.dist = [0]*(n+1)",
			"        parent = [n]*(n+1)",
			"        weight = [e]*(n+1)",
			"        stack = [root]",
			"        while stack:",
			"            now = stack.pop()",
			"            for next, w in adj[now]:",
			"                if next == parent[now]: continue",
			"                self.depth[next] = self.depth[now]+1",
			"                self.dist[next] = self.dist[now]+w",
			"                parent[next] = now",
			"                weight[next] = w",
			"                stack.append(next)",
			"        super().__init__(parent, weight, op, e, n.bit_length())",
			"    def move(self, fr, k):",
			"        fr = super().move(fr, k)",
			"        return fr if fr != self.N-1 else None",
			"    def prod(self, fr, k):",
			"        fr, w = super().move_prod(fr, k)",
			"        return w if fr != self.N-1 else None",
			"    def move_prod(self, fr, k):",
			"        fr, w = super().move_prod(fr, k)",
			"        return (fr, w) if fr != self.N-1 else None",
			"    def lca(self, a, b):",
			"        if self.depth[a] < self.depth[b]:",
			"            a, b = b, a",
			"        d = self.depth[a]-self.depth[b]",
			"        i = 0",
			"        while d:",
			"            if d&1:",
			"                a = self.doubling_next[i][a]",
			"            i += 1",
			"            d >>= 1",
			"        if a == b: return a",
			"        for i in range(self.K, -1, -1):",
			"            if self.doubling_next[i][a] != self.doubling_next[i][b]:",
			"                a = self.doubling_next[i][a]",
			"                b = self.doubling_next[i][b]",
			"        return self.next[a]",
			"    def path_prod(self, a, b):",
			"        c = self.lca(a, b)",
			"        d = self.depth[a]-self.depth[c]",
			"        i = 0",
			"        wa = self.e",
			"        while d:",
			"            if d&1:",
			"                wa = self.op(wa, self.doubling_weight[i][a])",
			"                a = self.doubling_next[i][a]",
			"            i += 1",
			"            d >>= 1",
			"        d = self.depth[b]-self.depth[c]",
			"        i = 0",
			"        wb = self.e",
			"        while d:",
			"            if d&1:",
			"                wb = self.op(self.doubling_weight[i][b], wb)",
			"                b = self.doubling_next[i][b]",
			"            i += 1",
			"            d >>= 1",
			"        return self.op(wa, wb)",
			"    def path_dist(self, a, b):",
			"        return self.dist[a]+self.dist[b]-2*self.dist[self.lca(a, b)]",
		],
		"description": "functional graphとtreeのダブリング"
	},

	"SWAG": {
		"prefix": "SWAG",
		"body": [
			"class Swag():",
			"",
			"    def __init__(self, op, e):",
			"        self.op = op",
			"        self.fq = [(e, e)]",
			"        self.bq = [(e, e)]",
			"",
			"    def push(self, x):",
			"        self.fq.append((x, self.op(self.fq[-1][1], x)))",
			"",
			"    def pop(self):",
			"        if len(self.bq) == 1:",
			"            while len(self.fq) > 1:",
			"                x = self.fq.pop()[0]",
			"                self.bq.append((x, self.op(x, self.bq[-1][1])))",
			"        if len(self.bq) == 1:",
			"            return None",
			"        else:",
			"            return self.bq.pop()[0]",
			"",
			"    def prod(self):",
			"        return self.op(self.bq[-1][1], self.fq[-1][1])",
			"",
			"    def __len__(self):",
			"        return len(self.fq)+len(self.bq)-2",
			"",
			"    def __str__(self):",
			"        return str(self.bq[1:][::-1]+self.fq[1:])",
			""
		],
		"description": "Sliding Window Aggregation"
	},

	"lowlink": {
		"prefix": "lowlink",
		"body": [
			"class LowLink():",
			"    def __init__(self, adj):",
			"        self.n = len(adj)",
			"        self.ord = [None]*self.n",
			"        self.low = [None]*self.n",
			"        self.son = [[] for _ in range(self.n)] # son[i] := 頂点iの子を格納したlist",
			"        self.back_edge = [[] for _ in range(N)] # back_edge[i] := 頂点iから出る後退辺の終点を格納したlist",
			"        self.tps = [] # 頂点のトポロジカルソート",
			"",
			"        # DFSでord, son, parent, tpsを求め、lowを初期化",
			"        t = 0 # 今までに訪れた頂点数",
			"        stack = [(None, 0)] # 直前にいた頂点, 今いる頂点",
			"        while stack: ",
			"            pre, now = stack.pop()",
			"            if self.ord[now] is not None: # 直前に通った辺が後退辺ならば",
			"                if self.ord[pre] < self.ord[now]: continue # 後退辺を根側から進んでいた場合は無視",
			"                self.low[pre] = min(self.low[pre], self.ord[now]) # low[pre]をord[now]でchmin",
			"                self.back_edge[pre].append(now)",
			"                continue",
			"            if pre is not None:",
			"                self.son[pre].append(now)",
			"            self.tps.append(now)",
			"            self.ord[now] = t # 行きがけ順を書き込む",
			"            self.low[now] = self.ord[now] # low[now]をord[now]で初期化",
			"            t += 1",
			"            for next in adj[now]:",
			"                if next == pre: continue",
			"                stack.append((now, next))",
			"",
			"        # ボトムアップ順にchminしてlowを求める",
			"        for u in reversed(self.tps[1:]):",
			"            for v in self.son[u]:",
			"                self.low[u] = min(self.low[u], self.low[v])",
			"",
			"    # 二重辺連結成分分解",
			"    def two_edge_connected_component(self):",
			"        tecc = [] # tecc[i] := 連結成分iに属する頂点の番号を格納したlist",
			"        tecc_idx = [None]*self.n # tecc_idx[i] := 頂点iが属する連結成分の番号(上記teccにおけるindexに対応)",
			"        tecc_tree = [] # 連結成分を頂点、橋を辺としたグラフ(木)の隣接リスト",
			"        sub_roots = [(None, 0)] # 橋を見つけるごとに、その先は部分木として別にDFSしなおす。",
			"        idx = 0 # 今いる頂点の連結成分の番号",
			"        while sub_roots:",
			"            stack = [sub_roots.pop()] # 部分木の根からDFS",
			"            tecc.append([]) # 今いる頂点の連結成分を格納するlistを追加",
			"            tecc_tree.append([]) # 今いる頂点の連結成分の隣接先を格納するlistを追加",
			"            while stack:",
			"                pre, now = stack.pop()",
			"                tecc[idx].append(now) # 今いる頂点を連結成分idxに追加",
			"                tecc_idx[now] = idx # 今いる頂点の連結成分の番号idxを記録",
			"                if pre is not None and idx != tecc_idx[pre]: # 直前に橋を通ってきていたら",
			"                    tecc_tree[idx].append(tecc_idx[pre]) # その橋で繋がれた2つの連結成分を辺で結ぶ",
			"                    tecc_tree[tecc_idx[pre]].append(idx)",
			"                for next in self.son[now]:",
			"                    if self.low[next] > self.ord[now]: # 橋なら",
			"                        sub_roots.append((now, next)) # その先は別の連結成分",
			"                    else: # そうでないなら",
			"                        stack.append((now, next)) # その先は同じ連結成分なのでDFSを続ける",
			"            idx += 1",
			"        return tecc, tecc_idx, tecc_tree",
			"",
			"    # 二重頂点連結成分分解",
			"    def biconnected_component(self):",
			"        bce = [] # bce[i] := 連結成分iに属する辺を格納したlist",
			"        bcv = [] # bcv[i] := 連結成分iに属する頂点を格納したlist",
			"        is_ap = [False]*self.n # is_ap[i] := 頂点iは関節点であるか(True/False)",
			"        sub_roots = [(None, 0)] #「ある子に対する関節点」を見つけるごとに、その子以降は部分木として別にDFSしなおす。",
			"        idx = 0 # 今いる頂点の連結成分の番号",
			"        while sub_roots:",
			"            stack = [sub_roots.pop()] # 部分木の根からDFS",
			"            bce.append([]) # 今いる頂点の連結成分に含まれる辺を格納するlistを追加",
			"            bcv.append([]) # 今いる頂点の連結成分に含まれる頂点を格納するlistを追加",
			"            if stack[0][0] is not None: # 直前に通った頂点(関節点)が存在するなら",
			"                bcv[idx].append(stack[0][0]) # それを連結成分idxに追加",
			"            while stack:",
			"                pre, now = stack.pop()",
			"                if pre is not None: # 直前に通った辺が存在するなら",
			"                    bce[idx].append((pre, now)) # 通ってきた辺を連結成分idxに追加",
			"                bcv[idx].append(now) # 今いる頂点を連結成分idxに追加",
			"                if now == 0: # 今いる頂点nowが根で",
			"                    if len(self.son[now]) >= 2: # 関節点であるなら",
			"                        for next in self.son[now]:",
			"                            is_ap[now] = True # 関節点であことを記録",
			"                            sub_roots.append((now, next)) # その先は別の連結成分",
			"                        bce.pop() # 「根の関節点のみ」の連結成分は存在しないが追加してしまっているので、例外的に削除する",
			"                        bcv.pop()",
			"                        idx -= 1",
			"                    else: # 関節点でないなら",
			"                        for next in self.son[now]:",
			"                            stack.append((now, next)) # その先は同じ連結成分なのでDFSを続ける",
			"                else: # 根でなく",
			"                    for next in self.son[now]:",
			"                        if self.low[next] >= self.ord[now]: # 子nextに対して関節点なら",
			"                            is_ap[now] = True # 関節点であることを記録",
			"                            sub_roots.append((now, next)) # その先は別の連結成分",
			"                        else: # 関節点でないなら",
			"                            stack.append((now, next)) # その先は同じ連結成分なのでDFSを続ける",
			"                if now == 0 and len(self.son[now]) <= 1:",
			"                    for back in self.back_edge[now]: # 今いる頂点から出る後退辺は同じ連結成分なので",
			"                        bce[idx].append((now, back)) # 連結成分idxに追加",
			"            idx += 1",
			"        return bce, bcv, is_ap",
			"",
			"    # block-cut treeを構築",
			"    def block_cut_tree(self):",
			"        bce, bcv, is_ap = self.biconnected_component() # 二重頂点連結成分分解",
			"        num_ap = sum(is_ap) # 関節点の個数",
			"        bc = [[] for _ in range(num_ap+len(bcv))] ",
			"        # bc[i] := block-cut tree上の頂点iに対応する頂点を格納したlist",
			"        # [0:num_ap)は関節点に対応する頂点で、その関節点のみがlistに含まれる",
			"        # [num_ap:len(bc))は連結成分に対応する頂点で、その連結成分から関節点を除いたものがlistに含まれる",
			"        # block-cut tree上の頂点iが関節点に対応している ⇔ i < num_ap",
			"        bc_idx = [None]*self.n",
			"        # bc_idx[i] := (元グラフの)頂点iが属するblock-cut tree上の頂点の番号(bc, bc_treeのindexに対応)",
			"        # 関節点でない頂点iについて、対応するbce, bcvのindexが知りたい場合、bc_idx[i]-num_apで取得可能。",
			"        bc_tree = [[] for _ in range(num_ap+len(bcv))] # bc_tree[i] := block-cut tree上の頂点iの隣接頂点を格納したlist",
			"        idx = 0 # 今見ているblock-cut tree上の頂点番号",
			"        for v in range(self.n): # (元グラフの)各頂点vについて",
			"            if is_ap[v]: # 関節点なら",
			"                bc[idx].append(v) # block-cut tree上の頂点idxにvを対応させる",
			"                bc_idx[v] = idx",
			"                idx += 1",
			"        for bcv_i in bcv: # 各連結成分の",
			"            for v in bcv_i: # 各頂点vについて",
			"                if is_ap[v]: # 関節点なら",
			"                    bc_tree[idx].append(bc_idx[v]) # block-cut tree上の頂点idxと関節点vに対応した頂点を辺で結ぶ",
			"                    bc_tree[bc_idx[v]].append(idx)",
			"                else: # そうでないなら",
			"                    bc[idx].append(v) # block-cut tree上の頂点idxに対応した頂点集合に頂点vを追加",
			"                    bc_idx[v] = idx",
			"            idx += 1",
			"        return bc, bc_idx, bc_tree, num_ap, bce, bcv, is_ap",
			"",
		],
		"description": "find bridges and articlation points"
	},

	"connected_adj": {
		"prefix": "Connected_Adj",
		"body": [
			"def ccd(adj, directed=False):",
			"    n = len(adj)",
			"    if directed:",
			"        radj = [[] for _ in range(n)]",
			"        for i, neighbor in enumerate(adj):",
			"            for j in neighbor:",
			"                radj[j].append(i)",
			"        seen = [False]*n",
			"        connected_adj = [] # ~[i] := 連結成分iについての隣接リスト",
			"        connected_adj_idx = [None]*n # ~[i] := (頂点iを含む連結成分の番号, 連結成分内での頂点iの番号)",
			"        connected_adj_prev = [] # ~[i][j] := 連結成分iにおける頂点jの、元グラフでの頂点番号",
			"        idx = 0",
			"        for s in range(n):",
			"            if seen[s]: continue",
			"            connected_adj.append([])",
			"            connected_adj_prev.append([])",
			"            seen[s] = True",
			"            stack = [s]",
			"            while stack:",
			"                now = stack.pop()",
			"                connected_adj_idx[now] = (idx, len(connected_adj[idx]))",
			"                connected_adj[idx].append(adj[now])",
			"                connected_adj_prev[idx].append(now)",
			"                for nxt in adj[now]:",
			"                    if seen[nxt]: continue",
			"                    seen[nxt] = True",
			"                    stack.append(nxt)",
			"                for nxt in radj[now]:",
			"                    if seen[nxt]: continue",
			"                    seen[nxt] = True",
			"                    stack.append(nxt)",
			"            idx += 1",
			"    else:",
			"        seen = [False]*n",
			"        connected_adj = [] # ~[i] := 連結成分iについての隣接リスト",
			"        connected_adj_idx = [None]*n # ~[i] := (頂点iを含む連結成分の番号, 連結成分内での頂点iの番号)",
			"        connected_adj_prev = [] # ~[i][j] := 連結成分iにおける頂点jの、元グラフでの頂点番号",
			"        idx = 0",
			"        for s in range(n):",
			"            if seen[s]: continue",
			"            connected_adj.append([])",
			"            connected_adj_prev.append([])",
			"            seen[s] = True",
			"            stack = [s]",
			"            while stack:",
			"                now = stack.pop()",
			"                connected_adj_idx[now] = (idx, len(connected_adj[idx]))",
			"                connected_adj[idx].append(adj[now])",
			"                connected_adj_prev[idx].append(now)",
			"                for nxt in adj[now]:",
			"                    if seen[nxt]: continue",
			"                    seen[nxt] = True",
			"                    stack.append(nxt)",
			"            idx += 1",
			"    for i in range(idx):",
			"        for j in range(len(connected_adj[i])):",
			"            for k in range(len(connected_adj[i][j])):",
			"                connected_adj[i][j][k] = connected_adj_idx[connected_adj[i][j][k]][1]",
			"    return connected_adj, connected_adj_idx, connected_adj_prev",
			"",
		],
		"description": "adjを連結成分ごとに分解"
	},
	
	"extend_gcd": {
		"prefix": "extend_gcd",
		"body": [
			"xy = [None, None] # ax+by = gcd(a, b)",
			"def extend_gcd(a, b, r=0):",
			"    if b == 0:",
			"        xy[r] = 1",
			"        xy[r^1] = 0",
			"        return a",
			"    d = extend_gcd(b, a%b, r^1)",
			"    xy[r^1] -= a//b*xy[r]",
			"    return d",
			"",
		],
		"description": "不定方程式 ax+by ≡ gcd(a, b)"
	},

	"中国剰余定理": {
		"prefix": "CRT",
		"body": [
			"xy = [None, None] # ax+by = gcd(a, b)",
			"def extend_gcd(a, b, r=0):",
			"    if b == 0:",
			"        xy[r] = 1",
			"        xy[r^1] = 0",
			"        return a",
			"    d = extend_gcd(b, a%b, r^1)",
			"    xy[r^1] -= a//b*xy[r]",
			"    return d",
			"",
			"def crt(MR): # (x ≡ r mod m)",
			"    nm = 1",
			"    x = 0",
			"    for m, r in MR:",
			"        extend_gcd(nm, m)",
			"        x += (r-x)*xy[0]%m*nm",
			"        nm *= m",
			"    return x",
			"",
		],
		"description": "Garnr's algorithm",
	},

	"離散対数問題": {
		"prefix": "modlog",
		"body": [
			"def modlog(x, y, m): # x^k ≡ y mod m を満たす最小のkを求める",
			"    n = int(m**0.5)+1",
			"    babys = {1: 0}",
			"    baby = 1",
			"    for b in range(n):",
			"        baby = baby*x%m",
			"        if baby == 1: break",
			"        babys[baby] = b+1",
			"    # extend_gcd(x, m) # mが合成数の時はこっちを使う。x, mが互いに素の必要あり。",
			"    # r = pow(xy[0], n, m)",
			"    r = pow(pow(x, m-2, m), n, m)",
			"    giant = 1",
			"    a = 0",
			"    while y*giant%m not in babys and a <= n:",
			"        giant = giant*r%m",
			"        a += 1",
			"    if y*giant%m not in babys: return None",
			"    return a*n+babys[y*giant%m]",
			"",
			"def cycle_length(x, p):",
			"    n = int(p**0.5)+1",
			"    babys = {1: 0}",
			"    baby = 1",
			"    for b in range(n):",
			"        baby = baby*x%p",
			"        if baby == 1: return b+1",
			"        babys[baby] = b+1",
			"    r = pow(pow(x, p-2, p), n, p)",
			"    giant = r%p",
			"    a = 1",
			"    while giant not in babys and a <= n:",
			"        giant = giant*r%p",
			"        a += 1",
			"    if giant not in babys: return None",
			"    return a*n+babys[giant]",
			"",
		],
		"description": "Baby-step Giant-step",
	},

	"matrix": {
		"prefix": "mat",
		"body": [
			"class Matrix():",
			"    def __init__(self, mat, mod=None):",
			"        self.mat = mat",
			"        self.n = len(mat)",
			"        self.m = len(mat[0])",
			"        self.mod = mod",
			"    def __mul__(self, other):",
			"        ret = Matrix([[0]*other.m for _ in range(self.n)], self.mod)",
			"        for i in range(self.n):",
			"            for j in range(other.m):",
			"                for k in range(self.m):",
			"                    ret[i][j] += self.mat[i][k]*other.mat[k][j]",
			"                    if self.mod is not None: ret[i][j] %= self.mod",
			"        return ret",
			"    def __add__(self, other):",
			"        ret = Matrix([[self.mat[i][j] for j in range(self.m)] for i in range(self.n)], self.mod)",
			"        for i in range(other.n):",
			"            for j in range(other.m):",
			"                ret[i][j] += other.mat[i][j]",
			"                if self.mod is not None: ret[i][j] %= self.mod",
			"        return ret",
			"    def __sub__(self, other):",
			"        ret = Matrix([[self.mat[i][j] for j in range(self.m)] for i in range(self.n)], self.mod)",
			"        for i in range(other.n):",
			"            for j in range(other.m):",
			"                ret[i][j] -= other.mat[i][j]",
			"                if self.mod is not None: ret[i][j] %= self.mod",
			"        return ret",
			"    def __pow__(self, scalar):",
			"        a = Matrix([[self.mat[i][j] for j in range(self.m)] for i in range(self.n)], self.mod)",
			"        ret = Matrix.e(self.n, self.mod)",
			"        while scalar:",
			"            if scalar&1:",
			"                ret *= a",
			"            a *= a",
			"            scalar >>= 1",
			"        return ret",
			"    def scalar_mul(self, a):",
			"        ret = Matrix([[self.mat[i][j] for j in range(self.m)] for i in range(self.n)], self.mod)",
			"        for i in range(self.n):",
			"            for j in range(self.m):",
			"                ret[i][j] *= a",
			"                if self.mod is not None: ret[i][j] %= self.mod",
			"        return ret",
			"    def __repr__(self) -> str:",
			"        return self.mat.__repr__()",
			"    def __getitem__(self, i):",
			"        return self.mat[i]",
			"    def __setitem__(self, i, x):",
			"        self.mat[i] = x",
			"    def __len__(self):",
			"        return len(self.mat)",
			"    def t(self):",
			"        return Matrix([list(column) for column in zip(*self.mat)], self.mod)",
			"    def turn(matrix):",
			"        if type(matrix) != 'Matrix':",
			"            return Matrix([list(column) for column in zip(*matrix)])",
			"        return Matrix([list(column) for column in zip(*matrix.mat)], matrix.mod)",
			"    def e(size, mod):",
			"        return Matrix([[i == j for j in range(size)] for i in range(size)], mod)",
			"    # 行列Aの法mod上の掃き出し法/Aは拡大係数行列か？",
			"    # mod=2の場合はBitsetを用いて定数倍(約wordsize=64倍)の高速化を行う",
			"    def gauss_jordan(A, mod, is_extended = False):",
			"        h, w = len(A), len(A[0])",
			"        rank = 0",
			"        if mod != 2:",
			"            for j in range(w):",
			"                if is_extended and j == w-1: break",
			"                pivot = None",
			"                for i in range(rank, h):",
			"                    if A[i][j] != 0:",
			"                        pivot = i",
			"                        break",
			"                if pivot is None: continue",
			"                A[rank], A[pivot] = A[pivot], A[rank]",
			"                inv = pow(A[rank][j], mod-2, mod)",
			"                for k in range(j, w):",
			"                    A[rank][k] = A[rank][k]*inv%mod",
			"                for i in range(h):",
			"                    if i == rank or A[i][j] == 0: continue",
			"                    a = A[i][j]",
			"                    for k in range(j, w):",
			"                        A[i][k] = (A[i][k]-A[rank][k]*a)%mod",
			"                rank += 1",
			"        else:",
			"            if type(A[0]) != Bitset:",
			"                for i in range(h):",
			"                    A[i] = Bitset(w, A[i])",
			"            for j in range(w):",
			"                if is_extended and j == w-1: break",
			"                pivot = None",
			"                for i in range(rank, h):",
			"                    if A[i][j] != 0:",
			"                        pivot = i",
			"                        break",
			"                if pivot is None: continue",
			"                A[rank], A[pivot] = A[pivot], A[rank]",
			"                for i in range(h):",
			"                    if i == rank or A[i][j] == 0: continue",
			"                    A[i] ^= A[rank]",
			"                rank += 1",
			"        return rank",
			"    # 連立一次方程式 Ax=b を法mod上で解く",
			"    def linear_equation(A, b, mod):",
			"        h, w = len(A), len(A[0])",
			"        M = [A[i]+[b[i]] for i in range(h)] # 拡大係数行列",
			"        rank = Matrix.gauss_jordan(M, mod, True)",
			"        # 解が無ければNoneをreturn",
			"        # rank行以下の拡大部分にα≠0が残っていた場合、0=αという等式が残っていることになり矛盾",
			"        for i in range(rank, h):",
			"            if M[i][w]: return None, None",
			"        ret = [M[i][w] for i in range(h)]",
			"        return ret, rank",
			"    # 行列Aの行列式を法mod上で求める",
			"    def det(A, mod):",
			"        n = len(A)",
			"        tmp = [[a for a in row] for row in A]",
			"        rank = 0",
			"        ret = 1",
			"        if mod != 2:",
			"            for j in range(n):",
			"                pivot = None",
			"                for i in range(rank, n):",
			"                    if tmp[i][j] != 0:",
			"                        pivot = i",
			"                        break",
			"                if pivot is None: return 0",
			"                if rank != pivot:",
			"                    tmp[rank], tmp[pivot] = tmp[pivot], tmp[rank]",
			"                    ret *= -1",
			"                inv = pow(tmp[rank][j], mod-2, mod)",
			"                ret = ret*tmp[rank][j]%mod",
			"                for k in range(j, n):",
			"                    tmp[rank][k] = tmp[rank][k]*inv%mod",
			"                for i in range(n):",
			"                    if i == rank or tmp[i][j] == 0: continue",
			"                    a = tmp[i][j]",
			"                    for k in range(j, n):",
			"                        tmp[i][k] = (tmp[i][k]-tmp[rank][k]*a)%mod",
			"                rank += 1",
			"        else:",
			"            if type(tmp[0]) != Bitset:",
			"                for i in range(n):",
			"                    tmp[i] = Bitset(n, tmp[i])",
			"            for j in range(n):",
			"                pivot = None",
			"                for i in range(rank, n):",
			"                    if tmp[i][j] != 0:",
			"                        pivot = i",
			"                        break",
			"                if pivot is None: return 0",
			"                tmp[rank], tmp[pivot] = tmp[pivot], tmp[rank]",
			"                for i in range(n):",
			"                    if i == rank or tmp[i][j] == 0: continue",
			"                    tmp[i] ^= A[rank]",
			"                rank += 1",
			"        return ret",
			"    # 行列Aの逆行列を法mod上で求める",
			"    def inv(A, mod):",
			"        n = len(A)",
			"        tmp = [[a for a in row] for row in A]",
			"        rank = 0",
			"        ret = Matrix.e(n, mod)",
			"        if mod != 2:",
			"            for j in range(n):",
			"                pivot = None",
			"                for i in range(rank, n):",
			"                    if tmp[i][j] != 0:",
			"                        pivot = i",
			"                        break",
			"                if pivot is None: return None",
			"                if rank != pivot:",
			"                    tmp[rank], tmp[pivot] = tmp[pivot], tmp[rank]",
			"                    ret[rank], ret[pivot] = ret[pivot], ret[rank]",
			"                inv = pow(tmp[rank][j], mod-2, mod)",
			"                for k in range(n):",
			"                    tmp[rank][k] = tmp[rank][k]*inv%mod",
			"                    ret[rank][k] = ret[rank][k]*inv%mod",
			"                for i in range(n):",
			"                    if i == rank or tmp[i][j] == 0: continue",
			"                    a = tmp[i][j]",
			"                    for k in range(n):",
			"                        tmp[i][k] = (tmp[i][k]-tmp[rank][k]*a)%mod",
			"                        ret[i][k] = (ret[i][k]-ret[rank][k]*a)%mod",
			"                rank += 1",
			"        else:",
			"            if type(tmp[0]) != Bitset:",
			"                for i in range(n):",
			"                    tmp[i] = Bitset(n, tmp[i])",
			"            for j in range(n):",
			"                pivot = None",
			"                for i in range(rank, n):",
			"                    if tmp[i][j] != 0:",
			"                        pivot = i",
			"                        break",
			"                if pivot is None: return None",
			"                tmp[rank], tmp[pivot] = tmp[pivot], tmp[rank]",
			"                ret[rank], ret[pivot] = ret[pivot], ret[rank]",
			"                for i in range(n):",
			"                    if i == rank or tmp[i][j] == 0: continue",
			"                    tmp[i] ^= tmp[rank]",
			"                    ret[i] ^= ret[rank]",
			"                rank += 1",
			"        return ret",
			"",
		],
		"description": "行列"
	},

	"algebra": {
		"prefix": "algebra",
		"body": [
			"import fractions as fc",
			"from functools import cmp_to_key",
			"",
			"def dist_sq(a, b): # 点a, bの距離^2",
			"    return (b[0]-a[0])**2+(b[1]-a[1])**2",
			"",
			"def area(a, b, c): # ab x ac(符号付き面積)",
			"    return (b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0])",
			"",
			"def normal(a, b, c): # abの法線ベクトルについて、cを始点にしたときの終点の座標",
			"    n = (a[1]-b[1], b[0]-a[0])",
			"    return (c[0]+n[0], c[1]+n[1])",
			"",
			"def middle(a, b): # 線分abの中点",
			"    return ((a[0]+b[0])/2, (a[1]+b[1])/2)",
			"",
			"def dot(a, b): # 内積",
			"    return a[0]*b[0]+a[1]*b[1]",
			"",
			"def vec(a, b):",
			"    return (b[0]-a[0], b[1]-a[1])",
			"",
			"def arg_sort(points, base=(0, 0)): # base基準の偏角ソート（反時計回り）",
			"    U = [] # [0, Π)にある頂点",
			"    D = [] # [Π, 2Π)にある頂点",
			"    for p in points:",
			"        if p[1] > base[1]: U.append(p)",
			"        elif p[1] < base[1]: D.append(p)",
			"        elif p[0] > base[0]: U.append(p)",
			"        else: D.append(p)",
			"    def cmp(p, q, b=base):",
			"        a = area(b, q, p)",
			"        if a != 0: return a # 外積で比較",
			"        return dist_sq(b, p)-dist_sq(b, q) # 基準点, p, qが直線上にある場合、距離でタイブレーク",
			"    return sorted(U, key=cmp_to_key(cmp))+sorted(D, key=cmp_to_key(cmp))",
			"",
			"def cmul(p, q): # 複素数の積 p*q (原点中心の回転+拡大縮小)",
			"    a, b = p",
			"    x, y = q",
			"    return [a*x-b*y, b*x+a*y] ",
			"",
			"def cdiv(p, q): # 複素数の除算 p/q (qをpに移すときの原点中心の回転角+倍率)",
			"    a, b = p",
			"    x, y = q",
			"    q_abs = x**2+y**2",
			"    return [(a*x+b*y)/q_abs, (-a*y+b*x)/q_abs]",
			"",
			"def get_convex(points):",
			"    n = len(points)",
			"    points.sort()",
			"    low = []",
			"    high = []",
			"    eq = []",
			"    for p in points[1:n-1]:",
			"        a = area(points[0], points[n-1], p)",
			"        if a < 0: low.append(p)",
			"        elif a > 0: high.append(p)",
			"        else: eq.append(p)",
			"    look = [[points[0]]+low+[points[n-1]], [points[n-1]]+sorted(high, reverse=True)+[points[0]]]",
			"    convex = []",
			"    for i in range(2):",
			"        c = [look[i][0]]",
			"        if len(look[i]) == 2:",
			"            if i: c.extend(reversed(eq))",
			"            else: c.extend(eq)",
			"        c.append(look[i][1])",
			"        for p in look[i][2:]:",
			"            while len(c) >= 2 and area(c[-2], c[-1], p) < 0:",
			"                c.pop()",
			"            c.append(p)",
			"        convex.extend(c)",
			"        convex.pop()",
			"    return convex",
			"",
			"def circumcenter(A, B, C): # 外心",
			"    if area(A, B, C) == 0:",
			"        return None",
			"    AB = vec(A, B)",
			"    AC = vec(A, C)",
			"    a = dot(AB, AC)",
			"    b = dist_sq(A, B)",
			"    c = dist_sq(A, C)",
			"    t = b*(a-c)/(2*a**2-2*b*c)",
			"    s = fc.Fraction(1, 2)-a*t/b",
			"    AO = (s*AB[0]+t*AC[0], s*AB[1]+t*AC[1])",
			"    O = (A[0]+AO[0], A[1]+AO[1])",
			"    return O",
			"",
		],
		"description": "幾何"
	},

	"ICPC_template": {
		"prefix": "icpc",
		"body": [
			"f = 'ICPC\\data'",
			"data = open(f, 'r')",
			"",
			"$1",
			"",
			"f = open('ICPC\\_ans', 'w')",
			"for a in ans:",
			"    f.write()",
			"f.close()",
		]
	},

	"z_algorithm": {
		"prefix": "z_algo",
		"body": [
			"def z_algo(S):",
			"    #Z[i] := Sのi文字目から最大で何文字Sのprefixと一致するか",
			"    N = len(S)",
			"    Z = [0]*N",
			"    Z[0] = N",
			"    i, j = 1, 0",
			"    while i < N:",
			"        while i+j < N and S[j] == S[i+j]:",
			"            j += 1",
			"        Z[i] = j",
			"        if j == 0:",
			"            i += 1",
			"            continue",
			"        k = 1",
			"        while i+k < N and k+Z[k] < j:",
			"            Z[i+k] = Z[k]",
			"            k += 1",
			"        i += k",
			"        j -= k",
			"    return Z",
			"",
		],
		"description": "z_algorithm"
	},

	"pop_count": {
		"prefix": "popcount",
		"body": [
			"def popcount(n):",
			"    c = (n&0x5555555555555555)+((n>>1)&0x5555555555555555)",
			"    c = (c&0x3333333333333333)+((c>>2)&0x3333333333333333)",
			"    c = (c&0x0f0f0f0f0f0f0f0f)+((c>>4)&0x0f0f0f0f0f0f0f0f)",
			"    c = (c&0x00ff00ff00ff00ff)+((c>>8)&0x00ff00ff00ff00ff)",
			"    c = (c&0x0000ffff0000ffff)+((c>>16)&0x0000ffff0000ffff)",
			"    c = (c&0x00000000ffffffff)+((c>>32)&0x00000000ffffffff)",
			"    return c",
		],
		"description": "立っているbitの個数を返す"
	},

	"MinMaxHeap": {
		"prefix": "mmh",
		"body": [
			"class MinMaxHeap:",
			"",
			"    def __init__(self, array=[]):",
			"        self.hq_min = [] # 最小ヒープ",
			"        self.hq_max = [] # 最大ヒープ",
			"        self.cnt = defaultdict(int) # cnt[x] := xの個数",
			"        self.size = len(array) # 要素数",
			"        for a in array:",
			"            self.push(a)",
			"",
			"    def push(self, x):",
			"        # xを追加",
			"        heappush(self.hq_min, x)",
			"        heappush(self.hq_max, -x)",
			"        self.cnt[x] += 1",
			"        self.size += 1",
			"",
			"    def erase(self, x):",
			"        # xを削除（複数あれば1つだけ、無ければ何もしない）",
			"        if self.cnt[x]:",
			"            self.cnt[x] -= 1",
			"            self.size -= 1",
			"",
			"    def get_min(self):",
			"        # 最小値を取得（空ならNone）",
			"        while self.hq_min and self.cnt[self.hq_min[0]] == 0:",
			"            heappop(self.hq_min)",
			"        if self.hq_min:",
			"            return self.hq_min[0]",
			"        return None",
			"",
			"    def get_max(self):",
			"        # 最大値を取得（空ならNone）",
			"        while self.hq_max and self.cnt[-self.hq_max[0]] == 0:",
			"            heappop(self.hq_max)",
			"        if self.hq_max:",
			"            return -self.hq_max[0]",
			"        return None",
			"",
			"    def __len__(self):",
			"        # len()で要素数を取得",
			"        return self.size",
			"",
			"    def __repr__(self):",
			"        # {各要素: 個数} の形で表示される。",
			"        return self.cnt",
			"",
		],
		"description": "最大値、最小値、指定キー削除ができるヒープ"
	},

	"float_floor": {
		"prefix": "floatfloor",
		"body": [
			"def float_floor(x, n) -> str:",
			"    x = str(float(x))",
			"    i = x.index('.')",
			"    return (x+'0'*n)[:i+n+1]",
			"",
		],
		"description": "xの小数点以下n桁までを切捨て+0埋めで表示",
	},

	"ternary_search": {
		"prefix": "sabutan",
		"body": [
			"class ${1:f}(object):",
			"    def __init__(self, x):",
			"        self.x = x",
			"    def calc(self):",
			"        return ${2:hoge}",
			"    def __eq__(self, other):",
			"        if not isinstance(other, ${1:f}):",
			"            return NotImplemented",
			"        return ${3:huga}",
			"    def __lt__(self, other):",
			"        if not isinstance(other, ${1:f}):",
			"            return NotImplemented",
			"        return ${4:piyo}",
			"    def __ne__(self, other):",
			"        return not self.__eq__(other)",
			"    def __le__(self, other):",
			"        return self.__lt__(other) or self.__eq__(other)",
			"    def __gt__(self, other):",
			"        return not self.__le__(other)",
			"    def __ge__(self, other):",
			"        return not self.__lt__(other)",
			"",
			"def findMin(f, l, r):",
			"    while r-l >= 3:",
			"        c1 = l+(r-l)//3",
			"        c2 = r-(r-l)//3",
			"        if f(c1) < f(c2): r = c2",
			"        else: l = c1",
			"    return min(list(range(l, r+1)), key=lambda k: f(k))",
			"",
			"def findMax(f, l, r):",
			"    while r-l >= 3:",
			"        c1 = l+(r-l)//3",
			"        c2 = r-(r-l)//3",
			"        if f(c1) > f(c2): r = c2",
			"        else: l = c1",
			"    return max(list(range(l, r+1)), key=lambda k: f(k))",
			"",
		],
		"description": "凸関数の最大値/最小値を三分探索"
	},

	"comparable_class_template": {
		"prefix": "cp_class",
		"body": [
			"class ${1:C}(object):",
			"    def __init__(self, x):",
			"        self.x = x",
			"    def calc(self):",
			"        return ${2:hoge}",
			"    def __eq__(self, other):",
			"        if not isinstance(other, ${1:C}):",
			"            return NotImplemented",
			"        return ${3:huga}",
			"    def __lt__(self, other):",
			"        if not isinstance(other, ${1:C}):",
			"            return NotImplemented",
			"        return ${4:piyo}",
			"    def __ne__(self, other):",
			"        return not self.__eq__(other)",
			"    def __le__(self, other):",
			"        return self.__lt__(other) or self.__eq__(other)",
			"    def __gt__(self, other):",
			"        return not self.__le__(other)",
			"    def __ge__(self, other):",
			"        return not self.__lt__(other)",
			"",
		],
		"description": "比較演算子の定義つきclassのテンプレート"
	},

	"imos":{
		"prefix": "imos",
		"body": [
			"class Imos:",
			"    def __init__(self, N) -> None:",
			"        self.N = N",
			"        self.A = [0]*(N+2)",
			"    def add_line(self, l, r, a, d) -> None:",
			"        self.A[l] += a",
			"        self.A[l+1] += d-a",
			"        self.A[r] -= d*(r-l)+a",
			"        self.A[r+1] += d*(r-l-1)+a",
			"    def get_array(self) -> None:",
			"        ret = [0]*self.N",
			"        ret[0] = self.A[0]",
			"        for i in range(self.N-1):",
			"            ret[i+1] = ret[i]+self.A[i+1]",
			"        for i in range(self.N-1):",
			"            ret[i+1] += ret[i]",
			"        return ret",
			"",
		],
		"description": "いもす法",
	},

	"count_triangle": {
		"prefix": "cnt_triangle",
		"body": [
			"def count_triangle(adj):",
			"    n = len(adj)",
			"    directed_adj = [set() for _ in range(n)]",
			"    for u, neighbour in enumerate(adj):",
			"        for v in neighbour:",
			"            if len(neighbour) < len(adj[v]):",
			"                directed_adj[u].add(v)",
			"            elif len(neighbour) == len(adj[v]):",
			"                if u not in directed_adj[v]:",
			"                    directed_adj[u].add(v)",
			"            else:",
			"                directed_adj[v].add(u)",
			"    cnt = 0",
			"    for neighbour in directed_adj:",
			"        for v in neighbour:",
			"           cnt += len(neighbour&directed_adj[v])",
			"    return cnt",
			"",
		],
		"description": "三角形の個数",
	},

	"bitset": {
		"prefix": "bitset",
		"body": [
			"def popcount(n):",
			"    c = (n&0x5555555555555555)+((n>>1)&0x5555555555555555)",
			"    c = (c&0x3333333333333333)+((c>>2)&0x3333333333333333)",
			"    c = (c&0x0f0f0f0f0f0f0f0f)+((c>>4)&0x0f0f0f0f0f0f0f0f)",
			"    c = (c&0x00ff00ff00ff00ff)+((c>>8)&0x00ff00ff00ff00ff)",
			"    c = (c&0x0000ffff0000ffff)+((c>>16)&0x0000ffff0000ffff)",
			"    c = (c&0x00000000ffffffff)+((c>>32)&0x00000000ffffffff)",
			"    return c",
			"",
			"class Bitset:",
			"    def __init__(self, size, x=0):",
			"        self.size = size",
			"        self.mask = (1<<size)-1",
			"        if type(x) is int:",
			"            self.set = x&self.mask",
			"        else:",
			"            self.set = 0",
			"            for i in range(min(self.size, len(x))):",
			"                if x[i]: self.set |= 1<<i",
			"    def __getitem__(self, i):",
			"        return (self.set>>i)&1",
			"    def __setitem__(self, i, x):",
			"        if x == 1 and (self.set>>i)&1 == 0:",
			"            self.set |= 1<<i",
			"        elif x == 0 and (self.set>>i)&1 == 1:",
			"            self.set ^= 1<<i",
			"    def __len__(self):",
			"        return self.size()",
			"    def __bool__(self):",
			"        return bool(self.set)",
			"    def __str__(self):",
			"        return f'{self.set:0{self.size}b}'",
			"    def __int__(self):",
			"        return self.set",
			"    def __invert__(self):",
			"        return Bitset(self.size, self.mask^self.set)",
			"    def __and__(self, other):",
			"        return Bitset(self.size, self.set&other.set)",
			"    def __or__(self, other):",
			"        return Bitset(self.size, self.set|other.set)",
			"    def __xor__(self, other):",
			"        return Bitset(self.size, self.set^other.set)",
			"    def __lshift__(self, k):",
			"        return Bitset(self.size, self.set<<k)",
			"    def __rshift__(self, k):",
			"        return Bitset(self.size, self.set>>k)",
			"    def __iand__(self, other):",
			"        self.set &= other.set&self.mask",
			"        return self",
			"    def __ior__(self, other):",
			"        self.set |= other.set&self.mask",
			"        return self",
			"    def __ixor__(self, other):",
			"        self.set ^= other.set&self.mask",
			"        return self",
			"    def __ilshift__(self, k):",
			"        self.set = (self.set<<k)&self.mask",
			"        return self",
			"    def __ilshift__(self, k):",
			"        self.set = (self.set<<k)&self.mask",
			"        return self",
			"    def __irshift__(self, k):",
			"        self.set >>= k",
			"        return self",
			"    def __eq__(self, other):",
			"        return self.size == other.size and self.set == other.set",
			"    def popcount(self):",
			"        x = self.set",
			"        ret = 0",
			"        while x:",
			"            ret += popcount(x&sys.maxsize)",
			"            x >>= 63",
			"        return ret",
			"    def popcount_range(self, l, r):",
			"        b = self&Bitset(self.size, (1<<r)-1^(1<<l)-1)",
			"        return b.popcount()",
			"    def trues(self, l, r):",
			"        self.set |= ((1<<r)-1^(1<<l)-1)&self.mask",
			"    def falses(self, l, r):",
			"        self.set &= (self.mask^(1<<r)-1^(1<<l)-1)&self.mask",
			"    def revs(self, l, r):",
			"        self.set ^= ((1<<r)-1^(1<<l)-1)&self.mask",
			"",
		],
		"description": "bitset擬き"
	},

	"up_sequence": {
		"prefix": "upseq",
		"body": [
			"class Up_seq:",
			"    def __init__(self, S):",
			"        self.N = len(S)",
			"        self.S = list(S)",
			"        self.seqs = SortedSet([0])",
			"        for i in range(1, self.N):",
			"            if S[i-1] > S[i]:",
			"                self.seqs.add(i)",
			"        self.seqs.add(self.N)",
			"    def is_up(self, l, r):",
			"        return r <= self.seqs.gt(l)",
			"    def update(self, i, c):",
			"        seq = self.seqs.le(i)",
			"        if i-1 >= 0:",
			"            if self.S[i-1] > self.S[i] and self.S[i-1] <= c:",
			"                self.seqs.discard(seq)",
			"            elif self.S[i-1] <= self.S[i] and self.S[i-1] > c:",
			"                self.seqs.add(i)",
			"        if i+1 < self.N:",
			"            if self.S[i] <= self.S[i+1] and c > self.S[i+1]:",
			"                self.seqs.add(i+1)",
			"            elif self.S[i] > self.S[i+1] and c <= self.S[i+1]:",
			"                self.seqs.discard(i+1)",
			"        self.S[i] = c",
			"",
		],
		"description": "昇順に並んだ区間を管理するデータ構造"
	},

	"update-with-sort":{
		"prefix": "UWS",
		"body": [
			"class Update_with_sort:",
			"    # keyに関して常に昇順に並べた状態での1点更新を補助する。",
			"    # 例えばサイズO(N+Q)のセグ木上で適切な葉に情報載せておくことで、1点key更新による並べ替えを",
			"    # その1点の移動のみで実現することを目指す。",
			"    # このクラスでは、その適切なindexを前計算する。",
			"    #",
			"    # データ構造を初期化する際は長さ N+len(update_querys) を用意して",
			"    # 0 ≤ i < N に対し",
			"    # date_structure[uws.now(i)] = X[i]",
			"    # とする。",
			"    class Node:",
			"        def __init__(self, key: int, index: int, query_index: int) -> None: ",
			"            self.key = key # 比較に使うkey",
			"            self.index = index # ノードの表す元のindex",
			"            self.query_index = query_index # クエリのindex",
			"        def __eq__(self, other):",
			"            return self.key == other.key and self.index == other.index and self.query_index == other.query_index",
			"        def __lt__(self, other):",
			"            return self.key < other.key or (self.key == other.key and self.index < other.index) or (self.key == other.key and self.index == other.index and self.query_index < other.query_index)",
			"        def __le__(self, other):",
			"            return self.__eq__(other) or self.__lt__(other)",
			"        def __gt__(self, other):",
			"            return not self.__le__(other)",
			"        def __ge__(self, other):",
			"            return not self.__lt__(other)",
			"",
			"    def __init__(self, keys, update_querys) -> None:",
			"        # keys[i]: (元の)i番目の要素について、ソートの基準とするkey",
			"        # update_querys[i]: (更新クエリのみ取り出したときの)i番目のクエリ: (index, x) -> (元の)index番目の要素のkeyをxに更新",
			"        nodes = [self.Node(k, i, -1) for i, k in enumerate(keys)]",
			"        self.update_index = [0]*len(update_querys)",
			"        for qi, q in enumerate(update_querys):",
			"            index, x = q",
			"            node = self.Node(x, index, qi)",
			"            nodes.append(node)",
			"            self.update_index[qi] = index",
			"        nodes.sort()",
			"        self.size = len(nodes)",
			"        self.node_index = [0]*len(update_querys)",
			"        self.last_node_index = [0]*len(keys)",
			"        self.original_index = [0]*self.size",
			"        # node_location = [0]*self.size",
			"        for i, node in enumerate(nodes):",
			"            self.original_index[i] = node.index",
			"            if node.query_index == -1:",
			"                self.last_node_index[node.index] = i",
			"                # node_location[i] = 1",
			"            else:",
			"                self.node_index[node.query_index] = i",
			"        # self.node_location = BIT(node_location)",
			"    def __len__(self):",
			"        return self.size",
			"    def now(self, index): # 元のindex番目の要素が今データ構造のでどこにあるか",
			"        return self.last_node_index[index]",
			"    def original(self, index): # データ構造のindex番目は元の何番目の要素か",
			"        return self.original_index[index]",
			"",
			"    # def now_sorted_idx(self, index): # 元のindex番目の要素が今key基準でソート後何番目か",
			"    #     i = self.now(index)",
			"    #     return self.node_location.sum(i)",
			"    # def original_sorted_idx(self, index): # 今key基準でソート後にindex番目の要素が元の何番目の要素か",
			"    #     i = self.node_location.lower_bound(index+1)-1",
			"    #     return self.original(i)",
			"",
			"    qi = 0",
			"    def update(self): # updateクエリを1つ処理、データ構造の移し元と移し先がreturnされる",
			"        i = self.update_index[self.qi]",
			"        now_index = self.last_node_index[i]",
			"        next_index = self.node_index[self.qi]",
			"        self.last_node_index[i] = next_index",
			"        self.qi += 1",
			"        # self.node_location.add(now_index, -1)",
			"        # self.node_location.add(next_index, 1)",
			"        return now_index, next_index",
			"",
		],
		"description": "keyの昇順に並べる操作と更新クエリをサポートする"
	},

	"xor基底": {
		"prefix": "xor_base",
		"body": [
			"basis = []",
			"for v in ${1:hoge}:",
			"    for b in basis:",
			"        v = min(v, v^b)",
			"    if v == 0: continue",
			"    for i in range(len(basis)):",
			"        if basis[i]^v < basis[i]: basis[i] = basis[i]^v",
			"    basis.append(v)",
			"basis.sort()",
			"",
		],
	},

	"Convex_Hull_Trick": {
		"prefix": "CHT",
		"body": [
			"class Convex_Hull_Trick:",
			"    def __init__(self, max_min, are_lines_sorted, are_querys_sorted):",
			"        self.max_min = max_min # maxなら0, minなら1",
			"        self.als = are_lines_sorted # 昇順",
			"        self.aqs = are_querys_sorted # 昇順",
			"        if self.als:",
			"            self.lines = []",
			"            self.head = 0",
			"        else:",
			"            self.lines = SortedMultiset()",
			"    def _f(self, i, x):",
			"        return self.lines[i][0]*x + self.lines[i][1]",
			"    def _check(self, l1, l2, l3):",
			"        return (l3[1]-l2[1])*(l2[0]-l1[0]) >= (l2[1]-l1[1])*(l3[0]-l2[0])",
			"    def add(self, a, b):",
			"        if self.max_min:",
			"            line = (-a, -b)",
			"        else:",
			"            line = (a, b)",
			"        if self.als:",
			"            while len(self.lines) >= 2 and self._check(self.lines[-2], self.lines[-1], line):",
			"                self.lines.pop()",
			"            self.lines.append(line)",
			"        else:",
			"            # そのうち書く",
			"            return",
			"    def get(self, x):",
			"        if self.als and self.aqs:",
			"            while len(self.lines)-self.head >= 2 and self._f(self.head, x) < self._f(self.head+1, x):",
			"                self.head += 1",
			"            return self._f(self.head, x)*(self.max_min*-2+1)",
			"        else:",
			"            ok, ng = -1, len(self.lines)-1",
			"            while(abs(ok-ng)>1):",
			"                mid = (ok+ng)//2",
			"                if self._f(mid, x) < self._f(mid+1, x):",
			"                    ok = mid",
			"                else:",
			"                    ng = mid",
			"            return self._f(ok+1, x)*(self.max_min*-2+1)",
			"",
		],
	},

	"Heavy_Light_Decomposition": {
		"prefix": "HLD",
		"body": [
			"class HLD:",
			"",
			"    # https://github.com/shakayami/ACL-for-python/blob/master/segtree.py",
			"",
			"    def __init__(self, adj, weights, op, e, root=0) -> None:",
			"        self.n = len(adj)",
			"        self.root = root",
			"        self.parent = [None]*self.n",
			"        stack = [root]",
			"        tps = []",
			"        while stack:",
			"            u = stack.pop()",
			"            tps.append(u)",
			"            for v in adj[u]:",
			"                adj[v].remove(u)",
			"                self.parent[v] = u",
			"                stack.append(v)",
			"        size = [1]*self.n",
			"        heavy = [None]*self.n",
			"        for u in reversed(tps):",
			"            ms = -inf",
			"            for v in adj[u]:",
			"                if size[v] > ms:",
			"                    heavy[u] = v",
			"                    ms = size[v]",
			"                size[u] += size[v]",
			"        del tps, size",
			"        self.idx = [None]*self.n",
			"        self.heavy_root = [None]*self.n",
			"        stack = [(None, root)]",
			"        i = 0",
			"        while stack:",
			"            p, u = stack.pop()",
			"            self.idx[u] = i",
			"            if p is not None:",
			"                self.parent[i] = self.idx[p]",
			"            if self.heavy_root[i] is None:",
			"                self.heavy_root[i] = i",
			"            for v in adj[u]:",
			"                if v == heavy[u]: continue",
			"                stack.append((u, v))",
			"            if heavy[u] is not None:",
			"                self.heavy_root[i+1] = self.heavy_root[i]",
			"                stack.append((u, heavy[u]))",
			"            i += 1",
			"        array = [None]*self.n",
			"        self.vertex = [None]*self.n",
			"        for u, w in enumerate(weights):",
			"            array[self.idx[u]] = w",
			"            self.vertex[self.idx[u]] = u",
			"        self.paths = self.segtree(array, op, e)",
			"",
			"    def prod(self, u, v):",
			"        u, v = self.idx[u], self.idx[v]",
			"        ret = self.paths.e",
			"        while self.heavy_root[u] != self.heavy_root[v]:",
			"            if u > v:",
			"                ret = self.paths.op(ret, self.paths.prod(self.heavy_root[u], u+1))",
			"                u = self.parent[self.heavy_root[u]]",
			"            else:",
			"                ret = self.paths.op(ret, self.paths.prod(self.heavy_root[v], v+1))",
			"                v = self.parent[self.heavy_root[v]]",
			"        if u > v: u, v = v, u",
			"        return self.paths.op(ret, self.paths.prod(u, v+1))",
			"",
			"    def set(self, u, w):",
			"        self.paths.set(self.idx[u], w)",
			"",
			"    def lca(self, u, v):",
			"        u, v = self.idx[u], self.idx[v]",
			"        while self.heavy_root[u] != self.heavy_root[v]:",
			"            if u > v:",
			"                u = self.parent[self.heavy_root[u]]",
			"            else:",
			"                v = self.parent[self.heavy_root[v]]",
			"        return self.vertex[min(u, v)]",
			"",
			"    def through(self, u, v, x):",
			"        u, v, x = self.idx[u], self.idx[v], self.idx[x]",
			"        while self.heavy_root[u] != self.heavy_root[v]:",
			"            if u > v:",
			"                if self.heavy_root[u] <= x <= u: return True",
			"                u = self.parent[self.heavy_root[u]]",
			"            else:",
			"                if self.heavy_root[v] <= x <= v: return True",
			"                v = self.parent[self.heavy_root[v]]",
			"        if u > v: u, v = v, u",
			"        return u <= x <= v",
			"",
		],
	},

	"disjoint sparse table": {
		"prefix": "DST",
		"body": [
			"class Sparse_Table:",
			"    def __init__(self, array, op):",
			"        self.op = op",
			"        self.n = len(array)",
			"        self.bl = (self.n-1).bit_length() # 段数になる",
			"        self.tables = [[a for a in array] for _ in range(self.bl)]",
			"        for i in range(1, self.bl):",
			"            table = self.tables[i]",
			"            for j in range(1<<i, 1<<self.bl, 1<<i+1):",
			"                for k in range(1, 1<<i):",
			"                    if j+k < self.n: table[j+k] = op(table[j+k-1], table[j+k])",
			"                    if j-k < self.n: table[j-1-k] = op(table[j-1-k], table[j-k])",
			"    def prod(self, l, r):",
			"        r -= 1",
			"        if l == r: return self.tables[0][l]",
			"        i = (l^r).bit_length()-1",
			"        return self.op(self.tables[i][l], self.tables[i][r])",
			"",
		],
	},

	"転倒数": {
		"prefix": "inversion",
		"body": [
		  "def inversion(pmt_array): # 0~N-1の順列の転倒数",
		  "    bt = BIT([0]*len(pmt_array))",
		  "    ret = 0",
		  "    for p in reversed(pmt_array):",
		  "        ret += bt.sum(p)",
		  "        bt.add(p, 1)",
		  "    return ret",
		  "",
		  "def swap_times(fr, to):",
		  "    to_idx = defaultdict(list)",
		  "    for i, t in enumerate(to):",
		  "        to_idx[t].append(i)",
		  "    idx = {t: 0 for t in to_idx.keys()}",
		  "    pmt_array = [None]*len(fr)",
		  "    for i, f in enumerate(fr):",
		  "        pmt_array[i] = to_idx[f][idx[f]]",
		  "        idx[f] += 1",
		  "    return inversion(pmt_array)"
		],
		"description": "転倒数"
	  },
	
	  "my_heap": {
		"prefix": "mhq",
		"body": [
		  "class My_heap:",
		  "    def __init__(self, array=None, key=None) -> None:",
		  "        if key is None:",
		  "            key = lambda x: x",
		  "        class C(object):",
		  "            def __init__(self, x):",
		  "                self.x = x",
		  "                self.kx = key(x)",
		  "            def __eq__(self, other):",
		  "                return self.kx == other.kx",
		  "            def __lt__(self, other):",
		  "                return self.kx < other.kx",
		  "            def __ne__(self, other):",
		  "                return not self.__eq__(other)",
		  "            def __le__(self, other):",
		  "                return self.__lt__(other) or self.__eq__(other)",
		  "            def __gt__(self, other):",
		  "                return not self.__le__(other)",
		  "            def __ge__(self, other):",
		  "                return not self.__lt__(other)",
		  "        self.C = C",
		  "        if array is None:",
		  "            self.hq = []",
		  "        else:",
		  "            self.hq = list(map(self.C, array))",
		  "            heapify(self.hq)",
		  "    def __len__(self) -> int:",
		  "        return len(self.hq)",
		  "    def __bool__(self):",
		  "        return len(self.hq) > 0",
		  "    def push(self, x) -> None:",
		  "        heappush(self.hq, self.C(x))",
		  "    def pop(self):",
		  "        return heappop(self.hq).x",
		  "    def top(self):",
		  "        return self.hq[0].x"
		],
		"description": "my_heap"
	  },

	  "2-SAT": {
		"prefix": "TwoSAT",
		"body": [
		  "class Two_SAT:",
		  "    def __init__(self, n) -> None:",
		  "        self.n = n",
		  "        self.adj = [[] for _ in range(2*n)]",
		  "    def add(self, x, y): # 否定したいときは~xを入れる",
		  "        if x >= 0 and y >= 0:",
		  "            self.adj[self.n+x].append(y)",
		  "            self.adj[self.n+y].append(x)",
		  "        elif x >= 0:",
		  "            y = ~y",
		  "            self.adj[self.n+x].append(self.n+y)",
		  "            self.adj[y].append(x)",
		  "        elif y >= 0:",
		  "            x = ~x",
		  "            self.adj[x].append(y)",
		  "            self.adj[self.n+y].append(self.n+x)",
		  "        else:",
		  "            x = ~x; y = ~y",
		  "            self.adj[x].append(self.n+y)",
		  "            self.adj[y].append(self.n+x)",
		  "    def solve(self):",
		  "        _, scc_idx, _ = sccd(self.adj)",
		  "        ret = [False]*self.n",
		  "        for x in range(self.n):",
		  "            i, j = scc_idx[x][0], scc_idx[self.n+x][0]",
		  "            if i == j:",
		  "                return None",
		  "            ret[x] = i > j",
		  "        return ret",
		  ""
		],
		"description": "2-SAT"
	  },
	
	  "半環上の最大部分配列問題": {
		"prefix": "kadane",
		"body": [
		  "class Kadane:",
		  "    def __init__(self, add, mul) -> None:",
		  "        self.add = add",
		  "        self.mul = mul",
		  "    def solve(self, array):",
		  "        ret = array[0]",
		  "        s = array[0]",
		  "        for a in array[1:]:",
		  "            s = self.add(self.mul(s, a), a)",
		  "            ret = self.add(ret, s)",
		  "        return ret"
		],
		"description": "半環上の最大部分配列問題"
	  },

	  "min-max-Ring": {
		"prefix": "mm_ring",
		"body": [
		  "class Matrix:",
		  "    def mul(this, that):",
		  "        ret = [[inf]*len(that[0]) for _ in range(len(this))]",
		  "        for i in range(len(this)):",
		  "            for k in range(len(this[0])):",
		  "                for j in range(len(that[0])):",
		  "                    ret[i][j] = min(ret[i][j], max(this[i][k], that[k][j]))",
		  "        return ret",
		  "    def pow(this, k):",
		  "        ret = Matrix.e(len(this))",
		  "        tmp = [[x for x in row] for row in this]",
		  "        while k:",
		  "            if k&1: ret = Matrix.mul(ret, tmp)",
		  "            tmp = Matrix.mul(tmp, tmp)",
		  "            k >>= 1",
		  "        return ret",
		  "    def e(size):",
		  "        return [[-inf if i == j else inf for j in range(size)] for i in range(size)]"
		],
		"description": "min-max-Ring"
	  },

	"永続セグ木": {
		"prefix": "PST",
		"body": [
			"class PersistentSegTree:",
			"    class Node:",
			"        def __init__(self, L, R, e) -> None:",
			"            self.L = L",
			"            self.R = R",
			"            self.x = e",
			"            self.left:PersistentSegTree.Node = None",
			"            self.right:PersistentSegTree.Node = None",
			"    def __init__(self, array, op, e, original_v=0) -> None:",
			"        self.length = len(array)",
			"        self.size = 1<<(self.length-1).bit_length()",
			"        self.op = op",
			"        self.e = e",
			"        self.original_v = original_v",
			"        self.version = {original_v: self.Node(0, self.size, e)}",
			"        stack = [self.version[self.original_v]]",
			"        tps = []",
			"        while stack:",
			"            node = stack.pop()",
			"            if node.R-node.L > 1:",
			"                tps.append(node)",
			"                node.left = self.Node(node.L, (node.L+node.R)>>1, self.e)",
			"                stack.append(node.left)",
			"                node.right = self.Node((node.L+node.R)>>1, node.R, self.e)",
			"                stack.append(node.right)",
			"            elif node.L < self.length:",
			"                node.x = array[node.L]",
			"        for node in reversed(tps):",
			"            node.x = self.op(node.left.x, node.right.x)",
			"    def set(self, old_v, new_v, i, x):",
			"        assert old_v in self.version and new_v not in self.version and 0 <= i < self.length",
			"        self.version[new_v] = self.Node(0, self.size, self.e)",
			"        old_node, new_node = self.version[old_v], self.version[new_v]",
			"        tps = []",
			"        while new_node.R-new_node.L > 1:",
			"            tps.append(new_node)",
			"            m = (new_node.L+new_node.R)>>1",
			"            if new_node.L <= i < m:",
			"                new_node.left = self.Node(new_node.L, m, self.e)",
			"                new_node.right = old_node.right",
			"                old_node, new_node = old_node.left, new_node.left",
			"            else:",
			"                new_node.left = old_node.left",
			"                new_node.right = self.Node(m, new_node.R, self.e)",
			"                old_node, new_node = old_node.right, new_node.right",
			"        new_node.x = x",
			"        for node in reversed(tps):",
			"            node.x = self.op(node.left.x, node.right.x)",
			"    def get(self, v, i):",
			"        assert v in self.version and 0 <= i < self.length",
			"        node = self.version[v]",
			"        while node.R-node.L > 1:",
			"            if node.L <= i < (node.L+node.R)>>1:",
			"                node = node.left",
			"            else:",
			"                node = node.right",
			"        return node.x",
			"    def all_prod(self, v):",
			"        assert v in self.version",
			"        return self.version[v].x",
			"    def prod(self, v, l, r):",
			"        assert v in self.version",
			"        if not 0 <= l < r <= self.length: return self.e",
			"        stack = [(self.version[v], l, r)]",
			"        ret = self.e",
			"        while stack:",
			"            node, l, r = stack.pop()",
			"            m = (node.L+node.R)>>1",
			"            if node.L == l and r == node.R:",
			"                ret = self.op(node.x, ret)",
			"            elif r <= m:",
			"                stack.append((node.left, l, r))",
			"            elif m <= l:",
			"                stack.append((node.right, l, r))",
			"            else:",
			"                stack.append((node.left, l, m))",
			"                stack.append((node.right, m, r))",
			"        return ret",
			"    def max_right(self, v, l, f):",
			"        assert v in self.version and 0 <= l < self.length and f(self.e)",
			"        tps = []",
			"        node = self.version[v]",
			"        while node.L != l:",
			"            if l < (node.L+node.R)>>1:",
			"                tps.append(node.right)",
			"                node = node.left",
			"            else:",
			"                node = node.right",
			"        tps.append(node)",
			"        x = self.e",
			"        for node in reversed(tps):",
			"            if not f(self.op(x, node.x)):",
			"                while node.R-node.L > 1:",
			"                    if f(self.op(x, node.left.x)):",
			"                        x = self.op(x, node.left.x)",
			"                        node = node.right",
			"                    else:",
			"                        node = node.left",
			"                return node.L",
			"            x = self.op(x, node.x)",
			"        return self.length",
			"    def min_left(self, v, r, f):",
			"        assert v in self.version and 0 < r <= self.length and f(self.e)",
			"        tps = []",
			"        node = self.version[v]",
			"        while node.R != r:",
			"            if (self.L+self.R)>>1 < r:",
			"                tps.append(node.left)",
			"                node = node.right",
			"            else:",
			"                node = node.left",
			"        tps.append(node)",
			"        x = self.e",
			"        for node in reversed(tps):",
			"            if not f(self.op(node.x, x)):",
			"                while node.R-node.L > 1:",
			"                    if f(self.op(node.right.x, x)):",
			"                        x = self.op(node.right.x, x)",
			"                        node = node.left",
			"                    else:",
			"                        node = node.right",
			"                return node.R",
			"            x = self.op(node.x, x)",
			"        return 0",
			"",
			"class RangeMexQuery:",
			"    def __init__(self, array) -> None:",
			"        self.pst = PersistentSegTree([-inf]*len(array), min, inf, 0)",
			"        for r, a in enumerate(array):",
			"            if a < len(array): self.pst.set(r, r+1, a, r)",
			"    def prod(self, l, r):",
			"        assert 0 <= l < r <= self.pst.length",
			"        return self.pst.max_right(r, 0, lambda x: x >= l)",
			"",
			"class RangeKthQuery:",
			"    def __init__(self, array) -> None:",
			"        self.array = array",
			"        self.comp = sorted(set(array))",
			"        self.comp_idx = {a: i for i, a in enumerate(self.comp)}",
			"        self.pst = PersistentSegTree([0]*len(self.comp), lambda x, y: x+y, 0, 0)",
			"        for r, a in enumerate(array):",
			"            self.pst.set(r, r+1, self.comp_idx[a], self.pst.get(r, self.comp_idx[a])+1)",
			"    def prod(self, l, r, k): # k: 0-indexed",
			"        assert 0 <= l < r <= len(self.array)",
			"        k += 1",
			"        l_node, r_node = self.pst.version[l], self.pst.version[r]",
			"        if r_node.x-l_node.x < k: return None",
			"        lx, rx = 0, 0",
			"        while l_node.R-l_node.L > 1:",
			"            if (rx+r_node.left.x)-(lx+l_node.left.x) < k:",
			"                lx = lx+l_node.left.x",
			"                l_node = l_node.right",
			"                rx = rx+r_node.left.x",
			"                r_node = r_node.right",
			"            else:",
			"                l_node = l_node.left",
			"                r_node = r_node.left",
			"        return self.comp[l_node.L]"
		],
		"description": "永続セグ木"
	},

	  "部分集合列挙": {
		"prefix": "subset_iterator",
		"body": [
			"def subset_iterater(s):",
			"    a = s",
			"    while a:",
			"        yield a",
			"        a = (a-1)&s",
			"",
		],
		"description": "aの部分集合のイテレータ"
	  },
	
	  "RangeManager": {
		"prefix": "RangeManager",
		"body": [
		  "class RangeManager:",
		  "    def __init__(self) -> None:",
		  "        self.left = [None]*M",
		  "        self.right = [None]*M",
		  "",
		  "    def insert(self, j):",
		  "        if j-1 < 0 or self.left[j-1] is None:",
		  "            self.left[j] = j",
		  "            if j+1 >= M or self.right[j+1] is None:",
		  "                self.right[j] = j",
		  "                return self.left[j], self.right[j]+1",
		  "            else:",
		  "                self.right[j] = self.right[j+1]",
		  "                self.left[self.right[j]] = j",
		  "                return self.left[j], self.right[j]+1",
		  "        else:",
		  "            if j+1 >= M or self.right[j+1] is None:",
		  "                self.right[j] = j",
		  "                self.left[j] = self.left[j-1]",
		  "                self.right[self.left[j]] = j",
		  "                return self.left[j], self.right[j]+1",
		  "            else:",
		  "                self.right[self.left[j-1]] = self.right[j+1]",
		  "                self.left[self.right[j+1]] = self.left[j-1]",
		  "            return self.left[self.left[j-1]], self.right[self.left[j-1]]+1"
		],
		"description": "RangeManager"
	  },

	  "重み最大長方形": {
		"prefix": "maxsqare",
		"body": [
		  "class SortedList:",
		  "    class Node:",
		  "        def __init__(self, j=None, x=None) -> None:",
		  "            self.j = j",
		  "            self.x = x",
		  "            self.nxt = None",
		  "        def __repr__(self) -> str:",
		  "            return (self.j, self.x).__repr__()",
		  "    class Tail:",
		  "        def __init__(self) -> None:",
		  "            self.pre = None",
		  "        def set(self, node):",
		  "            self.pre = node",
		  "            node.nxt = self",
		  "    ",
		  "    def __init__(self, m) -> None:",
		  "        self.m = m",
		  "        self.head = self.Node()",
		  "        now = self.head",
		  "        for i in range(M):",
		  "            nxt = self.Node(i, 0)",
		  "            now.nxt = nxt",
		  "            now = nxt",
		  "        self.tail = self.Tail()",
		  "        self.tail.set(now)",
		  "    ",
		  "    def _to_zero(self, pre, now):",
		  "        pre.nxt = now.nxt",
		  "        self.tail.pre.nxt = now",
		  "        self.tail.set(now)",
		  "        now.x = 0",
		  "    ",
		  "    def iterate(self, i):",
		  "        cnt = 0",
		  "        pre = self.head",
		  "        now = self.head.nxt",
		  "        while cnt < M:",
		  "            cnt += 1",
		  "            if A[i][now.j] >= m:",
		  "                now.x += 1",
		  "                yield now.j, now.x",
		  "                pre = now",
		  "                now = now.nxt",
		  "            else:",
		  "                if now.nxt is self.tail:",
		  "                    now.x = 0",
		  "                else:",
		  "                    self._to_zero(pre, now)",
		  "                    now = pre.nxt",
		  "",
		  "class RangeManager:",
		  "    def __init__(self) -> None:",
		  "        self.left = [None]*M",
		  "        self.right = [None]*M",
		  "",
		  "    def insert(self, j):",
		  "        if j-1 < 0 or self.left[j-1] is None:",
		  "            self.left[j] = j",
		  "            if j+1 >= M or self.right[j+1] is None:",
		  "                self.right[j] = j",
		  "                return self.left[j], self.right[j]+1",
		  "            else:",
		  "                self.right[j] = self.right[j+1]",
		  "                self.left[self.right[j]] = j",
		  "                return self.left[j], self.right[j]+1",
		  "        else:",
		  "            if j+1 >= M or self.right[j+1] is None:",
		  "                self.right[j] = j",
		  "                self.left[j] = self.left[j-1]",
		  "                self.right[self.left[j]] = j",
		  "                return self.left[j], self.right[j]+1",
		  "            else:",
		  "                self.right[self.left[j-1]] = self.right[j+1]",
		  "                self.left[self.right[j+1]] = self.left[j-1]",
		  "            return self.left[self.left[j-1]], self.right[self.left[j-1]]+1",
		  "",
		  "def solve(m):",
		  "    ret = 0",
		  "    sl = SortedList(m)",
		  "    for i in range(N):",
		  "        rm = RangeManager()",
		  "        for j, x in sl.iterate(i):",
		  "            l, r = rm.insert(j)",
		  "            ret = max(ret, S[i+1][r]-S[i+1][l]-S[i+1-x][r]+S[i+1-x][l])",
		  "    return ret"
		],
		"description": "重み最大長方形"
	  },

	  "YesNo": {
		"prefix": "YesNo",
		"body": [
			"print('Yes' if ${1:hoge} else 'No')",
		]
	  },

	  "Aho-Corasick法": {
		"prefix": "ahocora",
		"body": [
			"sys.setrecursionlimit(200000)",
			"class AhoCorasick_Node:",
			"    def __init__(self, a=None) -> None:",
			"        self.a = a",
			"        self.son = {}",
			"        self.fail = self",
			"        self.output = None",
			"        self.nxt_output_node = self",
			"        self.dp = 0",
			"    ",
			"    def find_nxt(self):",
			"        if self.nxt_output_node is self:",
			"            return self",
			"        if self.nxt_output_node.output is None:",
			"            self.nxt_output_node = self.nxt_output_node.find_nxt()",
			"        return self.nxt_output_node",
			"",
			"class AhoCorasick:",
			"    def __init__(self, words) -> None:",
			"        self.words = words",
			"        self.head = AhoCorasick_Node()",
			"        self._build_Trie()",
			"        self._set_fail()",
			"",
			"    def _build_Trie(self):",
			"        for w_idx, word in enumerate(self.words):",
			"            node = self.head",
			"            for a in word:",
			"                if a not in node.son:",
			"                    node.son[a] = AhoCorasick_Node(a)",
			"                node = node.son[a]",
			"            node.output = w_idx",
			"",
			"    def _set_fail(self):",
			"        dq = deque([self.head])",
			"        while dq:",
			"            now = dq.pop()",
			"            for a, nxt in now.son.items():",
			"                node = now.fail",
			"                while a not in node.son and node.fail is not node:",
			"                    node = node.fail",
			"                if a in node.son and node.son[a] is not nxt:",
			"                    nxt.fail = node.son[a]",
			"                else:",
			"                    nxt.fail = self.head",
			"                nxt.nxt_output_node = nxt.fail",
			"                dq.appendleft(nxt)",
			"    ",
			"    def enum(self, text):",
			"        node = self.head",
			"        # ret = defaultdict(list)",
			"        ret = [[] for _ in range(len(self.words))]",
			"        for i, a in enumerate(text):",
			"            while a not in node.son and node.fail is not node:",
			"                node = node.fail",
			"            if a in node.son:",
			"                node = node.son[a]",
			"",
			"            if node.output is not None:",
			"                w_idx = node.output",
			"                ret[w_idx].append(i+1-len(self.words[w_idx]))",
			"            output_node = node",
			"            while output_node.find_nxt() is not self.head:",
			"                output_node = output_node.nxt_output_node",
			"                w_idx = output_node.output",
			"                ret[w_idx].append(i+1-len(self.words[w_idx]))",
			"",
			"        return ret",
			"    ",
			"    def cnt(self, text):",
			"        tps = []",
			"        dq = deque([self.head])",
			"        while dq:",
			"            now = dq.pop()",
			"            now.dp = 0",
			"            tps.append(now)",
			"            for nxt in now.son.values():",
			"                dq.appendleft(nxt)",
			"",
			"        node = self.head",
			"        ret = [0]*len(self.words)",
			"        for a in text:",
			"            while a not in node.son and node.fail is not node:",
			"                node = node.fail",
			"            if a in node.son:",
			"                node = node.son[a]",
			"            node.dp += 1",
			"",
			"        for node in reversed(tps[1:]):",
			"            if node.output is not None:",
			"                w_idx = node.output",
			"                ret[w_idx] += node.dp",
			"            node.fail.dp += node.dp",
			"        return ret"
		],
		"description": "Aho-Corasick法"
	  },
	
	"ローリングハッシュ": {
		"prefix": "roriha",
		"body": [
			"class RollingHash:",
			"    BASE = 20200213",
			"    MOD = (1<<61) - 1",
			"    MASK30 = (1<<30) - 1",
			"    MASK31 = (1<<31) - 1",
			"    MASK61 = (1<<61) - 1",
			"    POSITIVISER = MOD << 2",
			"",
			"    def __init__(self, string) -> None:",
			"        self.length = len(string)",
			"        self.pow = [1] * (self.length + 1)",
			"        self.hash_acc = [0] * (self.length + 1)",
			"        for i, s in enumerate(string):",
			"            self.pow[i+1] = RollingHash._mod(RollingHash._mul(self.pow[i], RollingHash.BASE))",
			"            self.hash_acc[i+1] = RollingHash._mod(RollingHash._mul(self.hash_acc[i], RollingHash.BASE) + RollingHash._xorshift(ord(s)+1))",
			"",
			"    def hash(self, l, r):",
			"        ret = self.hash_acc[r] - RollingHash._mul(self.hash_acc[l], self.pow[r-l])",
			"        if ret < 0: ret += RollingHash.POSITIVISER",
			"        return RollingHash._mod(ret)",
			"",
			"    def _mul(a, b):",
			"        au, ad = a >> 31, a & RollingHash.MASK31",
			"        bu, bd = b >> 31, b & RollingHash.MASK31",
			"        y = au * bd + ad * bu",
			"        x = (ad * bd + ",
			"             ((y & RollingHash.MASK30) << 31) + (y >> 30) + ",
			"             (au * bu << 1))",
			"        return x",
			"    ",
			"    def _mod(x):",
			"        if x < RollingHash.MOD:",
			"            return x",
			"        return (x >> 61) + (x & RollingHash.MASK61) - RollingHash.MOD",
			"",
			"    def _xorshift(x):",
			"        return x ^ (x << 13) ^ (x >> 17) ^ (x << 5)"
		],
		"description": "ローリングハッシュ"
	},

	"部分永続UF": {
		"prefix": "PUF",
		"body": [
			"class PersistentUnionFind:",
			"    ",
			"    def __init__(self, N) -> None:",
			"        self.N = N",
			"        self.parent = [-1]*N",
			"        self.no_root_time = [inf]*N",
			"        self.size_history = [[(-inf, 1)] for _ in range(N)]",
			"        self.last_time = -inf",
			"    ",
			"    def find(self, x, t=inf):",
			"        while self.parent[x] >= 0 and t >= self.no_root_time[x]:",
			"            x = self.parent[x]",
			"        return x",
			"    ",
			"    def union(self, x, y, t):",
			"        if t <= self.last_time:",
			"            raise ValueError",
			"        self.last_time = t",
			"        x = self.find(x)",
			"        y = self.find(y)",
			"        if x == y:",
			"            self.now_time += 1",
			"            return False",
			"        if self.parent[x] > self.parent[y]:",
			"            x, y = y, x",
			"        self.parent[x] += self.parent[y]",
			"        self.parent[y] = x",
			"        self.no_root_time[y] = t",
			"        self.size_history[x].append((t, -self.parent[x]))",
			"        return True",
			"    ",
			"    def same(self, x, y, t=inf):",
			"        return self.find(x, t) == self.find(y, t)",
			"    ",
			"    def size(self, x, t=inf):",
			"        x = self.find(x, t)",
			"        i = bisect.bisect_right(self.size_history[x], (t, inf)) - 1",
			"        return self.size_history[x][i][1]",
			""
		],
		"description": "部分永続UF"
	},

	"永続配列": {
		"prefix": "PA",
		"body": [
			"class PersistentArray:",
			"    class Node:",
			"        def __init__(self, L, R) -> None:",
			"            self.L = L",
			"            self.R = R",
			"            self.x = None",
			"            self.left = None",
			"            self.right = None",
			"    def __init__(self, array, original_v=0) -> None:",
			"        self.length = len(array)",
			"        self.size = 1<<(self.length-1).bit_length()",
			"        self.original_v = original_v",
			"        self.version = {original_v: self.Node(0, self.size)}",
			"        stack = [self.version[self.original_v]]",
			"        while stack:",
			"            node = stack.pop()",
			"            if node.R-node.L > 1:",
			"                node.left = self.Node(node.L, (node.L+node.R)>>1)",
			"                stack.append(node.left)",
			"                node.right = self.Node((node.L+node.R)>>1, node.R)",
			"                stack.append(node.right)",
			"            else:",
			"                node.x = array[node.L] if node.L < self.length else None",
			"    def set(self, old_v, new_v, i, x):",
			"        assert old_v in self.version and new_v not in self.version and 0 <= i < self.length",
			"        self.version[new_v] = self.Node(0, self.size)",
			"        old_node, new_node = self.version[old_v], self.version[new_v]",
			"        while new_node.R-new_node.L > 1:",
			"            m = (new_node.L+new_node.R)>>1",
			"            if new_node.L <= i < m:",
			"                new_node.left = self.Node(new_node.L, m)",
			"                new_node.right = old_node.right",
			"                old_node, new_node = old_node.left, new_node.left",
			"            else:",
			"                new_node.left = old_node.left",
			"                new_node.right = self.Node(m, new_node.R)",
			"                old_node, new_node = old_node.right, new_node.right",
			"        new_node.x = x",
			"    def get(self, v, i):",
			"        if i < 0: i += self.length",
			"        assert v in self.version and 0 <= i < self.length",
			"        node = self.version[v]",
			"        while node.R-node.L > 1:",
			"            if node.L <= i < (node.L+node.R)>>1:",
			"                node = node.left",
			"            else:",
			"                node = node.right",
			"        return node.x",
			"    def get_array(self, v):",
			"        assert v in self.version",
			"        stack = [self.version[v]]",
			"        array = [None]*self.length",
			"        while stack:",
			"            node = stack.pop()",
			"            if node.R-node.L > 1:",
			"                if node.right.L < self.length:",
			"                    stack.append(node.right)",
			"                stack.append(node.left)",
			"            else:",
			"                array[node.L] = node.x",
			"        return array"
		],
		"description": "永続配列"
	},

	"辺属性HLD": {
		"prefix": "HLDE",
		"body": [
			"class HLD_for_EdgeAttribute:",
			"",
			"    # https://github.com/shakayami/ACL-for-python/blob/master/segtree.py",
			"",
			"    def __init__(self, n, E, op, e, root=0) -> None:",
			"        self.n = n",
			"        self.E = [None]*n",
			"        adj = [[] for _ in range(n)]",
			"        for i, e in enumerate(E):",
			"            u, v, w = e",
			"            adj[u].append((v, w))",
			"            adj[v].append((u, w))",
			"            self.E[i] = (u, v)",
			"        self.root = root",
			"        self.parent = [None]*self.n",
			"        stack = [root]",
			"        tps = []",
			"        while stack:",
			"            u = stack.pop()",
			"            tps.append(u)",
			"            for v, w in adj[u]:",
			"                adj[v].remove((u, w))",
			"                self.parent[v] = u",
			"                stack.append(v)",
			"        size = [1]*self.n",
			"        heavy = [None]*self.n",
			"        for u in reversed(tps):",
			"            ms = -inf",
			"            for v, _ in adj[u]:",
			"                if size[v] > ms:",
			"                    heavy[u] = v",
			"                    ms = size[v]",
			"                size[u] += size[v]",
			"        del tps, size",
			"        self.idx = [None]*self.n",
			"        self.heavy_root = [None]*self.n",
			"        stack = [(None, root)]",
			"        i = 0",
			"        while stack:",
			"            p, u = stack.pop()",
			"            self.idx[u] = i",
			"            if p is not None:",
			"                self.parent[i] = self.idx[p]",
			"            if self.heavy_root[i] is None:",
			"                self.heavy_root[i] = i",
			"            for v, _ in adj[u]:",
			"                if v == heavy[u]:",
			"                    continue",
			"                stack.append((u, v))",
			"            if heavy[u] is not None:",
			"                self.heavy_root[i+1] = self.heavy_root[i]",
			"                stack.append((u, heavy[u]))",
			"            i += 1",
			"        self.vertex = [None]*self.n",
			"        array = [e]*self.n",
			"        for u in range(self.n):",
			"            self.vertex[self.idx[u]] = u",
			"            for v, w in adj[u]:",
			"                array[self.idx[v]] = w",
			"        self.paths = self.segtree(array, op, e)",
			"",
			"    def prod(self, u, v):",
			"        u, v = self.idx[u], self.idx[v]",
			"        ret = self.paths.e",
			"        while self.heavy_root[u] != self.heavy_root[v]:",
			"            if u > v:",
			"                ret = self.paths.op(ret, self.paths.prod(self.heavy_root[u], u+1))",
			"                u = self.parent[self.heavy_root[u]]",
			"            else:",
			"                ret = self.paths.op(ret, self.paths.prod(self.heavy_root[v], v+1))",
			"                v = self.parent[self.heavy_root[v]]",
			"        if u > v: u, v = v, u",
			"        return self.paths.op(ret, self.paths.prod(u+1, v+1))",
			"",
			"    def set(self, i, w):",
			"        u, v = self.E[i]",
			"        i = max(self.idx[u], self.idx[v])",
			"        self.paths.set(self.idx[i], w)",
			"",
			"    def lca(self, u, v):",
			"        u, v = self.idx[u], self.idx[v]",
			"        while self.heavy_root[u] != self.heavy_root[v]:",
			"            if u > v:",
			"                u = self.parent[self.heavy_root[u]]",
			"            else:",
			"                v = self.parent[self.heavy_root[v]]",
			"        return self.vertex[min(u, v)]",
			"",
			"    def through(self, u, v, x):",
			"        u, v, x = self.idx[u], self.idx[v], self.idx[x]",
			"        while self.heavy_root[u] != self.heavy_root[v]:",
			"            if u > v:",
			"                if self.heavy_root[u] <= x <= u: return True",
			"                u = self.parent[self.heavy_root[u]]",
			"            else:",
			"                if self.heavy_root[v] <= x <= v: return True",
			"                v = self.parent[self.heavy_root[v]]",
			"        if u > v: u, v = v, u",
			"        return u <= x <= v"
		],
		"description": "辺属性HLD"
	},

	"デカい素数リスト": {
		"prefix": "primenums",
		"body": [
			"PL = [1031472581,",
			"     1151415359,",
			"     1239116167,",
			"     1361066123,",
			"     1401055423,",
			"     1571755261,",
			"     1652572013,",
			"     1681451617,",
			"     1728645521,",
			"     1871234227,",
			"     1981252517]"
		],
		"description": "デカい素数リスト"
	},

	"MergeSortTree": {
	"prefix": "MST",
	"body": [
		"class MergeSortTree:",
		"",
		"    class Node:",
		"        def __init__(self, karr, varr, op, e):",
		"            self.karr = karr",
		"            self.varr = varr",
		"            self.sarr = list(accumulate(varr, func=op, initial=e))",
		"            self.op = op",
		"            self.e = e",
		"        def bisect_left_sum(self, x):",
		"            return self.sarr[bisect.bisect_left(self.karr, x)]",
		"        def bisect_right_sum(self, x):",
		"            \"\"\"",
		"                sum([a for a in varr if a <= x])",
		"            \"\"\"",
		"            return self.sarr[bisect.bisect_right(self.karr, x)]",
		"        def merge(x, y):",
		"            xkarr, xvarr = x.karr, x.varr",
		"            ykarr, yvarr = y.karr, y.varr",
		"            zkarr = []",
		"            zvarr = []",
		"            i, j = 0, 0",
		"            while i < len(xkarr) and j < len(ykarr):",
		"                if xkarr[i] <= ykarr[j]:",
		"                    zkarr.append(xkarr[i])",
		"                    zvarr.append(xvarr[i])",
		"                    i += 1",
		"                else:",
		"                    zkarr.append(ykarr[j])",
		"                    zvarr.append(yvarr[j])",
		"                    j += 1",
		"            while i < len(xkarr):",
		"                zkarr.append(xkarr[i])",
		"                zvarr.append(xvarr[i])",
		"                i += 1",
		"            while j < len(ykarr):",
		"                zkarr.append(ykarr[j])",
		"                zvarr.append(yvarr[j])",
		"                j += 1",
		"            return MergeSortTree.Node(zkarr, zvarr, x.op, x.e)",
		"    ",
		"    # https://github.com/shakayami/ACL-for-python/blob/master/segtree.py",
		"    # ↑ を MergeSortTree 用に改造しました。いつもお世話になっております。",
		"    class segtree():",
		"        n=1",
		"        size=1",
		"        log=2",
		"        d=[0]",
		"        op=None",
		"        e=10**15",
		"        def __init__(self,V,OP,E):",
		"            self.n=len(V)",
		"            self.op=OP",
		"            self.e=E",
		"            self.log=(self.n-1).bit_length()",
		"            self.size=1<<self.log",
		"            self.d=[MergeSortTree.Node([], [], OP, E) for i in range(2*self.size)]",
		"            for i in range(self.n):",
		"                self.d[self.size+i]=V[i]",
		"            for i in range(self.size-1,0,-1):",
		"                self.update(i)",
		"        def get(self,p):",
		"            assert 0<=p and p<self.n",
		"            return self.d[p+self.size]",
		"        def prod_bisect_left(self,l,r,x):",
		"            assert 0<=l and l<=r and r<=self.n",
		"            sml=self.e",
		"            smr=self.e",
		"            l+=self.size",
		"            r+=self.size",
		"            while(l<r):",
		"                if (l&1):",
		"                    sml=self.op(sml,self.d[l].bisect_left_sum(x))",
		"                    l+=1",
		"                if (r&1):",
		"                    smr=self.op(self.d[r-1].bisect_left_sum(x),smr)",
		"                    r-=1",
		"                l>>=1",
		"                r>>=1",
		"            return self.op(sml,smr)",
		"        def prod_bisect_right(self,l,r,x):",
		"            assert 0<=l and l<=r and r<=self.n",
		"            sml=self.e",
		"            smr=self.e",
		"            l+=self.size",
		"            r+=self.size",
		"            while(l<r):",
		"                if (l&1):",
		"                    sml=self.op(sml,self.d[l].bisect_right_sum(x))",
		"                    l+=1",
		"                if (r&1):",
		"                    smr=self.op(self.d[r-1].bisect_right_sum(x),smr)",
		"                    r-=1",
		"                l>>=1",
		"                r>>=1",
		"            return self.op(sml,smr)",
		"        def update(self,k):",
		"            self.d[k]=MergeSortTree.Node.merge(self.d[2*k],self.d[2*k+1])",
		"        def __str__(self):",
		"            return str([self.get(i) for i in range(self.n)])",
		"",
		"    def __init__(self, karr, varr, op, e):",
		"        self.karr = karr[:]",
		"        self.varr = varr[:]",
		"        self.op = op",
		"        self.e = e",
		"        self.st = MergeSortTree.segtree([MergeSortTree.Node([k], [v], op, e) for k, v in zip(karr, varr)], op, e)",
		"    def prod_bisect_left(self, l, r, x):",
		"        \"\"\"",
		"            op([varr[a] for i in range(l, r) if karr[i] < x])",
		"        \"\"\"",
		"        return self.st.prod_bisect_left(l, r, x)",
		"    def prod_bisect_right(self, l, r, x):",
		"        \"\"\"",
		"            op([varr[a] for i in range(l, r) if karr[i] <= x])",
		"        \"\"\"",
		"        return self.st.prod_bisect_right(l, r, x)"
	],
	"description": "MergeSortTree"
	},

	"ランレングス圧縮": {
		"prefix": "RLE",
		"body": [
			"${1:array}_rle = [(k, len(list(g))) for k, g in groupby(${1:array})]"
		],
		"description": "ランレングス圧縮",
	},

	"Manachar": {
        "prefix": "Manachar",
        "body": [
            "class Manachar:",
            "",
            "    def __init__(self, S):",
            "        self.S = S",
            "        self.R_odd = self._manacher(S)",
            "        S_even = \"\\$\" + \"\\$\".join(S) + \"\\$\"",
            "        self.R_even = [r>>1 for r in self._manacher(S_even)[2:-1:2]]",
            "",
            "    def _manacher(self, S):",
            "        \"\"\"",
            "            mana[i] := S[i] を中心とした最長回文の半径",
            "",
            "            例：",
            "                abaaababa",
            "                121412321",
            "        \"\"\"",
            "        i = 0",
            "        j = 0",
            "        mana = [0]*len(S)",
            "        while i < len(S):",
            "            while i-j >= 0 and i+j < len(S) and S[i-j] == S[i+j]:",
            "                j += 1",
            "            mana[i] = j",
            "            k = 1",
            "            while i-k >= 0 and k+mana[i-k] < j:",
            "                mana[i+k] = mana[i-k]",
            "                k += 1",
            "            i += k",
            "            j -= k",
            "        return mana",
            "    ",
            "    def is_palindrome(self, l, r):",
            "        if (r-l)&1 == 0:",
            "            return (r-l+1)>>1 <= self.R_even[((l+r-1)>>1)] ",
            "        else:",
            "            return (r-l+1)>>1 <= self.R_odd[((l+r-1)>>1)]",
        ],
        "description": "Manachar"
    },
}